"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["4669"],{3256:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>l,default:()=>h,contentTitle:()=>s,assets:()=>o,toc:()=>c,metadata:()=>a});var a=JSON.parse('{"id":"guides-concepts/callbacks","title":"Callbacks","description":"Some Win32 APIs are asynchronous: a function call doesn\'t complete and","source":"@site/docs/guides-concepts/callbacks.md","sourceDirName":"guides-concepts","slug":"/guides-concepts/callbacks","permalink":"/docs/guides-concepts/callbacks","draft":false,"unlisted":false,"editUrl":"https://github.com/halildurmus/win32/tree/main/website/docs/guides-concepts/callbacks.md","tags":[],"version":"current","lastUpdatedBy":"Sol Birnbaum","lastUpdatedAt":1744291582000,"frontMatter":{"title":"Callbacks"},"sidebar":"mainSidebar","previous":{"title":"Patterns for Memory Management","permalink":"/docs/guides-concepts/memory-patterns"},"next":{"title":"COM","permalink":"/docs/com"}}'),i=t(5893),r=t(65);let l={title:"Callbacks"},s=void 0,o={},c=[{value:"Creating Callbacks",id:"creating-callbacks",level:2}];function d(e){let n={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.a)(),...e.components},{CommonViewSourceCode:t}=n;return t||function(e,n){throw Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("CommonViewSourceCode",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Some Win32 APIs are ",(0,i.jsx)(n.strong,{children:"asynchronous"}),": a function call doesn't complete and\nreturn all the information requested immediately. Dart has the ",(0,i.jsx)(n.code,{children:"async"}),"/",(0,i.jsx)(n.code,{children:"await"}),"\npattern for handling asynchronous calls within Dart libraries and packages, but\nthe C-based Win32 API model does not have a similar construct."]}),"\n",(0,i.jsxs)(n.p,{children:["Therefore, calling Win32 APIs that are asynchronous is handled through\n",(0,i.jsx)(n.strong,{children:"callbacks"}),", where you pass a function that Win32 executes first to pass data\nback."]}),"\n",(0,i.jsx)(n.h2,{id:"creating-callbacks",children:"Creating Callbacks"}),"\n",(0,i.jsxs)(n.p,{children:["Dart currently offers ",(0,i.jsx)(n.strong,{children:"two ways"})," to create callback functions that can be\ninvoked from native functions:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://api.dart.dev/stable/dart-ffi/NativeCallable/NativeCallable.isolateLocal.html",children:(0,i.jsx)(n.code,{children:"NativeCallable.isolateLocal"})}),": Constructs a\n",(0,i.jsx)(n.code,{children:"NativeCallable"})," that must be invoked from the ",(0,i.jsx)(n.strong,{children:"same"})," thread that created\nit."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"https://api.dart.dev/stable/dart-ffi/NativeCallable/NativeCallable.listener.html",children:(0,i.jsx)(n.code,{children:"NativeCallable.listener"})}),": Constructs a\n",(0,i.jsx)(n.code,{children:"NativeCallable"})," that can be invoked from ",(0,i.jsx)(n.strong,{children:"any"})," thread. However, there is a\n",(0,i.jsx)(n.strong,{children:"restriction"})," \u2014 only ",(0,i.jsx)(n.code,{children:"void"})," functions are supported."]}),"\n"]}),"\n",(0,i.jsxs)(n.admonition,{type:"note",children:[(0,i.jsxs)(n.p,{children:["In most cases, utilizing ",(0,i.jsx)(n.code,{children:"NativeCallable.isolateLocal"})," should suffice. However,\nif you encounter a ",(0,i.jsx)(n.code,{children:"Cannot invoke native callback outside an isolate."})," error, it\nindicates that the API you're calling operates in a ",(0,i.jsx)(n.strong,{children:"different thread\ncontext"}),"."]}),(0,i.jsxs)(n.p,{children:["In such cases, if the callback is a ",(0,i.jsx)(n.code,{children:"void"})," function, consider using\n",(0,i.jsx)(n.code,{children:"NativeCallable.listener"}),". If not, there is currently no way to call that\nparticular API."]}),(0,i.jsx)(n.admonition,{type:"simple",children:(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"work-in-progress"})," ",(0,i.jsx)(n.a,{href:"https://github.com/dart-lang/language/blob/main/working/333%20-%20shared%20memory%20multithreading/proposal.md",children:"proposal"})," is underway to introduce a\n",(0,i.jsx)(n.a,{href:"https://github.com/dart-lang/language/blob/main/working/333%20-%20shared%20memory%20multithreading/proposal.md#upgrading-dartffi",children:(0,i.jsx)(n.code,{children:"NativeCallable.shared"})})," constructor, enabling callbacks\nto be invoked from ",(0,i.jsx)(n.strong,{children:"any"})," thread without restrictions."]})})]}),"\n",(0,i.jsxs)(n.p,{children:["For example, let's look at the ",(0,i.jsx)(n.a,{href:"https://learn.microsoft.com/windows/win32/api/wingdi/nf-wingdi-enumfontfamiliesexw",children:(0,i.jsx)(n.code,{children:"EnumFontFamiliesEx"})}),"\nfunction, which ",(0,i.jsx)(n.strong,{children:"enumerates"})," all uniquely-named ",(0,i.jsx)(n.strong,{children:"fonts"})," in the system that\nmatch a specified set of font characteristics. ",(0,i.jsx)(n.code,{children:"EnumFontFamiliesEx"})," takes a\n",(0,i.jsx)(n.code,{children:"LOGFONT"})," struct which contains information about the fonts to enumerate."]}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"https://pub.dev/documentation/win32/latest/win32/EnumFontFamiliesEx.html",children:"Dart function signature"})," looks like this:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"int EnumFontFamiliesEx(\n        int hdc,\n        Pointer<LOGFONT> lpLogfont,\n    // highlight-next-line\n        Pointer<NativeFunction<FONTENUMPROC>> lpProc,\n        int lParam,\n        int dwFlags) { ... }\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Notice the ",(0,i.jsx)(n.strong,{children:"third"})," parameter \u2014 a pointer to the callback function\n",(0,i.jsx)(n.a,{href:"https://pub.dev/documentation/win32/latest/win32/FONTENUMPROC.html",children:(0,i.jsx)(n.code,{children:"FONTENUMPROC"})}),". This is called ",(0,i.jsx)(n.strong,{children:"once"})," for every enumerated\nfont, and is defined as:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"typedef FONTENUMPROC = Int32 Function(Pointer<LOGFONT> lpelfe,\n    Pointer<TEXTMETRIC> lpntme, DWORD FontType, LPARAM lParam);\n"})}),"\n",(0,i.jsxs)(n.p,{children:["To create a callback function, first define a Dart function that matches the\ntypes in the ",(0,i.jsx)(n.strong,{children:"native callback function"})," above. Replace any ",(0,i.jsx)(n.strong,{children:"integer"})," types\nwith a Dart ",(0,i.jsx)(n.code,{children:"int"})," type where applicable."]}),"\n",(0,i.jsx)(n.p,{children:"Here's an example:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"int enumerateFonts(\n    Pointer<LOGFONT> logFont, Pointer<TEXTMETRIC> _, int __, int ___) {\n  // Get extended information from the font.\n  final logFontEx = logFont.cast<ENUMLOGFONTEX>();\n  print(logFontEx.ref.elfFullName);\n  return TRUE; // continue enumeration.\n}\n"})}),"\n",(0,i.jsx)(n.admonition,{type:"simple",children:(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Since we only use the ",(0,i.jsx)(n.strong,{children:"first"})," parameter, we use the Dart ",(0,i.jsx)(n.code,{children:"_"})," convention to\nindicate that other parameter values are ",(0,i.jsx)(n.strong,{children:"ignored"}),"."]}),"\n",(0,i.jsxs)(n.li,{children:["This callback returns ",(0,i.jsx)(n.code,{children:"TRUE"})," to indicate that the enumeration should\n",(0,i.jsx)(n.strong,{children:"continue"}),". Alternatively, we could ",(0,i.jsx)(n.strong,{children:"stop"})," the callback from being fired\nfor the next enumerated value by returning ",(0,i.jsx)(n.code,{children:"FALSE"})," (for example, if we had\nfound a specific font that we were looking for)."]}),"\n"]})}),"\n",(0,i.jsxs)(n.p,{children:["Now that we have our function callback, we can use it with ",(0,i.jsx)(n.code,{children:"EnumFontFamiliesEx"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="fonts.dart"',children:"import 'dart:ffi';\n\nimport 'package:ffi/ffi.dart';\nimport 'package:win32/win32.dart';\n\nint enumerateFonts(\n    Pointer<LOGFONT> logFont, Pointer<TEXTMETRIC> _, int __, int ___) {\n  // Get extended information from the font.\n  final logFontEx = logFont.cast<ENUMLOGFONTEX>();\n  print(logFontEx.ref.elfFullName);\n  return TRUE; // continue enumeration.\n}\n\nvoid main() {\n  final hDC = GetDC(NULL);\n  final searchFont = calloc<LOGFONT>()\n    ..ref.lfCharSet = HANGUL_CHARSET;\n  // highlight-start\n  final lpProc = NativeCallable<FONTENUMPROC>.isolateLocal(\n    enumerateFonts,\n    exceptionalReturn: 0,\n  );\n  // highlight-end\n\n  // highlight-next-line\n  EnumFontFamiliesEx(hDC, searchFont, lpProc.nativeFunction, 0, 0);\n\n  lpProc.close(); // Close the callback when it's no longer needed.\n  free(searchFont);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, we first create a struct ",(0,i.jsx)(n.code,{children:"LOGFONT"})," containing our required\nsearch characteristics (fonts that support the Hangul, or Korean, character\nset). We then create a ",(0,i.jsx)(n.code,{children:"NativeCallable"})," for the Dart callback function using the\n",(0,i.jsx)(n.code,{children:"NativeCallable.isolateLocal"})," constructor. Finally, we call the\n",(0,i.jsx)(n.code,{children:"EnumFontFamiliesEx"})," API to initiate the enumeration. The Dart\n",(0,i.jsx)(n.code,{children:"enumerateFonts()"})," function will now be called once for every discovered font\nthat matches the search characteristics."]}),"\n",(0,i.jsx)(t,{href:"https://github.com/halildurmus/win32/blob/main/examples/fonts.dart"})]})}function h(e={}){let{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}}}]);