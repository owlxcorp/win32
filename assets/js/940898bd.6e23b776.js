"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["2103"],{2740:function(e,n,t){t.r(n),t.d(n,{frontMatter:()=>a,default:()=>h,contentTitle:()=>o,assets:()=>l,toc:()=>c,metadata:()=>r});var r=JSON.parse('{"id":"guides-concepts/memory-patterns","title":"Patterns for Memory Management","description":"Consider the following bad example of a function that calls","source":"@site/docs/guides-concepts/memory-patterns.md","sourceDirName":"guides-concepts","slug":"/guides-concepts/memory-patterns","permalink":"/docs/guides-concepts/memory-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/halildurmus/win32/tree/main/website/docs/guides-concepts/memory-patterns.md","tags":[],"version":"current","lastUpdatedBy":"Sol Birnbaum","lastUpdatedAt":1744291582000,"frontMatter":{"title":"Patterns for Memory Management"},"sidebar":"mainSidebar","previous":{"title":"Structs","permalink":"/docs/guides-concepts/structs"},"next":{"title":"Callbacks","permalink":"/docs/guides-concepts/callbacks"}}'),i=t(5893),s=t(65);let a={title:"Patterns for Memory Management"},o=void 0,l={},c=[{value:"The <code>try</code>/<code>finally</code> pattern",id:"the-tryfinally-pattern",level:2},{value:"The <code>using</code> pattern",id:"the-using-pattern",level:2}];function d(e){let n={a:"a",admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components},{CommonViewSourceCode:t,Details:r}=n;return t||p("CommonViewSourceCode",!0),r||p("Details",!0),(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(n.p,{children:["Consider the following ",(0,i.jsx)(n.strong,{children:"bad"})," example of a function that calls\n",(0,i.jsx)(n.a,{href:"https://learn.microsoft.com/windows/win32/api/combaseapi/nf-combaseapi-cocreateguid",children:(0,i.jsx)(n.code,{children:"CoCreateGuid"})})," to return a string:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="guid.dart"',children:"import 'dart:ffi';\n\nimport 'package:ffi/ffi.dart';\nimport 'package:win32/win32.dart';\n\n// BAD: Don't do this, since the memory for pGuid may not be released.\nString createGUID() {\n  // highlight-next-line\n  final pGuid = calloc<GUID>();\n\n  final hr = CoCreateGuid(pGuid);\n  // highlight-next-line\n  if (FAILED(hr)) throw WindowsException(hr);\n  final guid = pGuid.ref.toString();\n  // highlight-next-line\n  free(pGuid);\n  return guid;\n}\n"})}),"\n",(0,i.jsxs)(r,{children:[(0,i.jsx)("summary",{children:"Can you see a potential bug in this code?"}),(0,i.jsxs)(n.p,{children:["Here's the problem: if ",(0,i.jsx)(n.code,{children:"CoCreateGuid()"})," fails, ",(0,i.jsx)(n.code,{children:"pGuid"})," will not be ",(0,i.jsx)(n.strong,{children:"released"}),"\nprior to the ",(0,i.jsx)(n.strong,{children:"exception"})," being thrown. In this example, there are simple\nsolutions (e.g., call ",(0,i.jsx)(n.code,{children:"free"})," in both ",(0,i.jsx)(n.strong,{children:"failure"})," and ",(0,i.jsx)(n.strong,{children:"success"})," scenarios).\nHowever, when you're allocating many different objects, this approach can lead\nto ",(0,i.jsx)(n.strong,{children:"unreadable code"})," with plenty of opportunities for ",(0,i.jsx)(n.strong,{children:"memory leaks"}),"."]})]}),"\n",(0,i.jsxs)(n.h2,{id:"the-tryfinally-pattern",children:["The ",(0,i.jsx)(n.code,{children:"try"}),"/",(0,i.jsx)(n.code,{children:"finally"})," pattern"]}),"\n",(0,i.jsxs)(n.p,{children:["One ",(0,i.jsx)(n.strong,{children:"effective"})," approach is using the ",(0,i.jsx)(n.code,{children:"try"}),"/",(0,i.jsx)(n.code,{children:"finally"})," pattern in Dart, which\nensures that the ",(0,i.jsx)(n.code,{children:"finally"})," clause will be ",(0,i.jsx)(n.strong,{children:"executed"})," regardless of whether an\n",(0,i.jsx)(n.strong,{children:"exception"})," is thrown."]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"// GOOD: This approach is safe and convenient.\nString createGUID() {\n  final pGuid = calloc<GUID>();\n  // highlight-next-line\n  try {\n    final hr = CoCreateGuid(pGuid);\n    if (FAILED(hr)) throw WindowsException(hr);\n    return pGuid.ref.toString();\n  // highlight-next-line\n  } finally {\n    free(pGuid);\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the above example, ",(0,i.jsx)(n.code,{children:"free"})," will be called regardless of whether\n",(0,i.jsx)(n.code,{children:"CoCreateGuid()"})," fails or not. There's no need to ",(0,i.jsx)(n.strong,{children:"allocate"})," the result to a\nseparate string before returning, as the ",(0,i.jsx)(n.code,{children:"finally"})," block ensures ",(0,i.jsx)(n.strong,{children:"proper\ncleanup"})," at the ",(0,i.jsx)(n.strong,{children:"appropriate time"}),"."]}),"\n",(0,i.jsxs)(n.h2,{id:"the-using-pattern",children:["The ",(0,i.jsx)(n.code,{children:"using"})," pattern"]}),"\n",(0,i.jsxs)(n.p,{children:["For simpler methods, the ",(0,i.jsx)(n.code,{children:"try"}),"/",(0,i.jsx)(n.code,{children:"finally"})," pattern works well. But as you add more\nmanually-allocated objects, this approach becomes more ",(0,i.jsx)(n.strong,{children:"unwieldy"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["For example, consider this function, which queries Windows for the ",(0,i.jsx)(n.strong,{children:"timestamp"}),"\nwhen the currently-running process was created:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",metastring:'title="process.dart"',children:"import 'dart:ffi';\n\nimport 'package:ffi/ffi.dart';\nimport 'package:win32/win32.dart';\n\nDateTime processCreationTime() {\n  final hProcess = GetCurrentProcess();\n  final pCreationTime = calloc<FILETIME>();\n  final pExitTime = calloc<FILETIME>();\n  final pKernelTime = calloc<FILETIME>();\n  final pUserTime = calloc<FILETIME>();\n  final pCreationSystemTime = calloc<SYSTEMTIME>();\n\n  try {\n    // Retrieve timing information for the current process.\n    var hr = GetProcessTimes(\n        hProcess, pCreationTime, pExitTime, pKernelTime, pUserTime);\n    if (FAILED(hr)) throw WindowsException(hr);\n\n    // Convert to UTC.\n    hr = FileTimeToSystemTime(pCreationTime, pCreationSystemTime);\n    if (FAILED(hr)) throw WindowsException(hr);\n    final SYSTEMTIME(:wYear, :wMonth, :wDay, :wHour, :wMinute, :wSecond) =\n        pCreationSystemTime.ref;\n    return DateTime.utc(wYear, wMonth, wDay, wHour, wMinute, wSecond).toLocal();\n  } finally {\n    free(pCreationTime);\n    free(pExitTime);\n    free(pKernelTime);\n    free(pUserTime);\n    free(pCreationSystemTime);\n  }\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["There are two problems with this code. Firstly, each variable has to be\nindividually ",(0,i.jsx)(n.strong,{children:"freed"}),". Secondly, the variable ",(0,i.jsx)(n.code,{children:"pCreationSystemTime"})," has to be\nallocated even if the first call fails. This can be a nuisance in larger\nmethods."]}),"\n",(0,i.jsxs)(n.p,{children:["An alternative approach is to use the ",(0,i.jsx)(n.a,{href:"https://pub.dev/documentation/ffi/latest/ffi/using.html",children:(0,i.jsx)(n.code,{children:"using"})})," pattern with an\n",(0,i.jsx)(n.a,{href:"https://pub.dev/documentation/ffi/latest/ffi/Arena-class.html",children:(0,i.jsx)(n.code,{children:"Arena"})})," object, which is a memory allocator that tracks memory\nallocations and automatically releases them when the ",(0,i.jsx)(n.code,{children:"using"})," scope ends."]}),"\n",(0,i.jsx)(n.p,{children:"Here's the same function written this way:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"DateTime processCreationTime() {\n  return using((arena) {\n    final hProcess = GetCurrentProcess();\n    final pCreationTime = arena<FILETIME>();\n    final pExitTime = arena<FILETIME>();\n    final pKernelTime = arena<FILETIME>();\n    final pUserTime = arena<FILETIME>();\n\n    // Retrieve timing information for the current process.\n    var hr = GetProcessTimes(\n        hProcess, pCreationTime, pExitTime, pKernelTime, pUserTime);\n    if (FAILED(hr)) throw WindowsException(hr);\n\n    // Convert to UTC.\n    final pCreationSystemTime = arena<SYSTEMTIME>();\n    hr = FileTimeToSystemTime(pCreationTime, pCreationSystemTime);\n    if (FAILED(hr)) throw WindowsException(hr);\n    final SYSTEMTIME(:wYear, :wMonth, :wDay, :wHour, :wMinute, :wSecond) =\n        pCreationSystemTime.ref;\n    return DateTime.utc(wYear, wMonth, wDay, wHour, wMinute, wSecond).toLocal();\n  });\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:["In the above code, the need for individual ",(0,i.jsx)(n.code,{children:"free"})," calls is dispensed with. When\nthe ",(0,i.jsx)(n.code,{children:"using"})," scope ends, the ",(0,i.jsx)(n.strong,{children:"arena"})," releases all the variables that have been\nallocated. ",(0,i.jsx)(n.code,{children:"Arena"}),"s can also be ",(0,i.jsx)(n.strong,{children:"nested"})," or ",(0,i.jsx)(n.strong,{children:"shared"})," across functions, which\ncan be useful when you need greater control over the ",(0,i.jsx)(n.strong,{children:"lifetime"})," of\nmanually-allocated ",(0,i.jsx)(n.strong,{children:"memory"}),"."]}),"\n",(0,i.jsxs)(n.admonition,{type:"tip",children:[(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:".toNativeUtf16()"})," String extension method supports passing a\n",(0,i.jsx)(n.strong,{children:"custom allocator"}),", making it compatible with ",(0,i.jsx)(n.code,{children:"Arena"}),"s:"]}),(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-dart",children:"final pTitle = 'Window title'.toNativeUtf16(allocator: arena);\n"})})]}),"\n",(0,i.jsx)(t,{href:"https://github.com/halildurmus/win32/blob/main/examples/process.dart"})]})}function h(e={}){let{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}function p(e,n){throw Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}}}]);