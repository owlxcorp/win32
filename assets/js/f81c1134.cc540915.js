"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([["5524"],{5865:function(n){n.exports=JSON.parse('{"archive":{"blogPosts":[{"id":"building-task-manager-app","metadata":{"permalink":"/blog/building-task-manager-app","source":"@site/blog/2024/07-16-building-task-manager-app/index.mdx","title":"Building a Task Manager App in Flutter with win32","description":"We\'ll build a Task Manager app to manage running Windows tasks in Flutter using the win32 package.","date":"2024-07-16T00:00:00.000Z","tags":[{"inline":true,"label":"win32","permalink":"/blog/tags/win-32"},{"inline":true,"label":"flutter","permalink":"/blog/tags/flutter"},{"inline":true,"label":"tutorial","permalink":"/blog/tags/tutorial"}],"readingTime":15.81,"hasTruncateMarker":true,"authors":[{"name":"Halil Durmus","title":"Software Engineer / Maintainer of win32","url":"https://halildurmus.dev","page":{"permalink":"/blog/authors/halildurmus"},"socials":{"github":"https://github.com/halildurmus"},"github":"https://github.com/halildurmus","imageURL":"https://github.com/halildurmus.png","key":"halildurmus"}],"frontMatter":{"title":"Building a Task Manager App in Flutter with win32","description":"We\'ll build a Task Manager app to manage running Windows tasks in Flutter using the win32 package.","slug":"building-task-manager-app","authors":"halildurmus","tags":["win32","flutter","tutorial"],"image":"https://ik.imagekit.io/npajaqrcn/blog/2024-07-16-building-task-manager-app/social.png","hide_table_of_contents":false},"unlisted":false,"nextItem":{"title":"Building a Service Manager CLI in Dart with win32","permalink":"/blog/building-service-manager-cli"}},"content":"![Task Manager App](/assets/landing-hero-showcase/task_manager.png)\\n\\n## Introduction\\n\\nIn this blog post, we will build a Task Manager app in Flutter using the\\n**win32** package. By utilizing the Windows APIs provided by **win32**, we\'ll\\ncreate an intuitive app to **view** and **manage** running tasks on a Windows\\nsystem.\\n\\nWhether you\'re a developer looking to enhance your Flutter skills or an\\nenthusiast eager to dive into Windows programming, this guide will walk you\\nthrough the process of creating your own Task Manager app from scratch.\\n\\n\x3c!--truncate--\x3e\\n\\nHere\'s what we\'ll cover:\\n\\n- [Feature Overview](#feature-overview)\\n- [Setting Up the Project](#setting-up-the-project)\\n  - [Creating a New Flutter Project](#creating-a-new-flutter-project)\\n  - [Installing Dependencies](#installing-dependencies)\\n- [Defining the Models](#defining-the-models)\\n- [Implementing Task Manager Logic](#implementing-task-manager-logic)\\n  - [Running a New Task](#running-a-new-task)\\n  - [Enumerating Running Tasks](#enumerating-running-tasks)\\n    - [Retrieving File Description](#retrieving-file-description)\\n    - [Extracting Task Icon](#extracting-task-icon)\\n  - [Terminating a Task](#terminating-a-task)\\n- [Building the UI](#building-the-ui)\\n  - [Setting Up the Main Entry Point](#setting-up-the-main-entry-point)\\n  - [Creating the Home Screen Skeleton](#creating-the-home-screen-skeleton)\\n  - [Loading and Displaying Tasks](#loading-and-displaying-tasks)\\n  - [Task Sorting, Searching, and Refreshing](#task-sorting-searching-and-refreshing)\\n  - [Task Termination](#task-termination)\\n  - [Task Creation](#task-creation)\\n- [Conclusion](#conclusion)\\n- [Source Code](#source-code)\\n\\n## Feature Overview\\n\\nOur Task Manager app will include the following key features:\\n\\n- **Enumerating running tasks:** View a list of running tasks, including their\\n  names, PIDs, and descriptions.\\n- **Searching and sorting tasks:** Search and sort tasks based on their name,\\n  PID, or description.\\n- **Starting a new task:** Start a new task by specifying its executable path\\n  directly within the app.\\n- **Terminating a task:** Terminate a running task by clicking the button next\\n  to the task.\\n\\n## Setting Up the Project\\n\\nBefore we dive into coding, let\u2019s set up our project.\\n\\n### Creating a New Flutter Project\\n\\nOpen your terminal and run:\\n\\n```cmd\\n> flutter create task_manager --platforms=windows\\n> cd task_manager\\n```\\n\\n### Installing Dependencies\\n\\nAdd the **ffi** and **win32** packages to your project with:\\n\\n```cmd title=\\"Terminal\\"\\nflutter pub add ffi win32\\n```\\n\\n## Defining the Models\\n\\nWe\'ll start by defining the models responsible for storing **task information**\\nand **sorting options**.\\n\\nCreate a new file named `models.dart` in the `lib\\\\src` directory and add the\\nfollowing code:\\n\\n```dart title=\\"models.dart\\"\\nimport \'dart:typed_data\';\\n\\n/// Specifies the field by which to sort the tasks.\\nenum SortBy {\\n  /// Sort by task name.\\n  name,\\n\\n  /// Sort by task PID (Process ID).\\n  pid,\\n\\n  /// Sort by task description.\\n  description,\\n}\\n\\n/// Specifies the order in which to sort the tasks.\\nenum SortOrder {\\n  /// Sort in ascending order.\\n  ascending,\\n\\n  /// Sort in descending order.\\n  descending,\\n}\\n\\n/// A Windows task with its icon, name, PID, and description.\\nclass Task {\\n  const Task({\\n    required this.iconAsBytes,\\n    required this.name,\\n    required this.pid,\\n    required this.description,\\n  });\\n\\n  /// The icon of the task.\\n  final Uint8List iconAsBytes;\\n\\n  /// The name of the task.\\n  final String name;\\n\\n  /// The PID (Process ID) of the task.\\n  final int pid;\\n\\n  /// The description of the task.\\n  final String description;\\n}\\n```\\n\\n## Implementing Task Manager Logic\\n\\nNext, we\'ll implement the functionality for managing Windows tasks, including\\nenumerating running tasks, starting new tasks, and terminating tasks.\\n\\nCreate a new file named `task_manager.dart` in the `lib\\\\src` directory and\\nadd the following code to set up the skeleton for managing Windows tasks:\\n\\n```dart title=\\"task_manager.dart\\"\\nimport \'dart:ffi\';\\nimport \'dart:typed_data\';\\n\\nimport \'package:ffi/ffi.dart\';\\nimport \'package:win32/win32.dart\';\\n\\nimport \'models.dart\';\\n\\n/// Provides functionality for managing Windows tasks, including:\\n/// - Enumerating running tasks\\n/// - Running a new task\\n/// - Terminating a running task\\nabstract class TaskManager {\\n  /// Runs a new task from the specified [path].\\n  ///\\n  /// Returns `true` if the task was successfully started; otherwise, `false`.\\n  static bool run(String path) {\\n    // TODO: Implement this method\\n    throw UnimplementedError();\\n  }\\n\\n  /// Retrieves a list of currently running tasks.\\n  ///\\n  /// Returns `null` if retrieval failed.\\n  static List<Task>? get tasks {\\n    // TODO: Implement this method\\n    throw UnimplementedError();\\n  }\\n\\n  /// Terminates a running task with the given [pid].\\n  ///\\n  /// Returns `true` if the task was successfully terminated; otherwise,\\n  /// `false`.\\n  static bool terminate(int pid) {\\n    // TODO: Implement this method\\n    throw UnimplementedError();\\n  }\\n}\\n```\\n\\nWith the skeleton in place, we can start implementing the task manager logic.\\n\\n### Running a New Task\\n\\nNow, let\'s implement the `run` function to **run a new task**.\\n\\n```dart title=\\"task_manager.dart\\"\\n/// Runs a new task from the specified [path].\\n///\\n/// Returns `true` if the task was successfully started; otherwise, `false`.\\nstatic bool run(String path) {\\n  final lpFile = path.toNativeUtf16();\\n  final result = ShellExecute(\\n    0,\\n    \'open\'.toNativeUtf16(),\\n    lpFile,\\n    nullptr,\\n    nullptr,\\n    SW_SHOWNORMAL,\\n  );\\n  free(lpFile);\\n  return result > 32;\\n}\\n```\\n\\nWe first convert the provided file path into a native UTF-16 format using the\\n`toNativeUtf16` extension method from `package:ffi`. This formatted path is then\\npassed along with other necessary parameters to [ShellExecute], specifying an\\naction to open the file and dictate how the new process window should appear.\\n\\nAfter executing the function, we free the allocated memory for the path to\\nensure efficient resource management. If the value returned by [ShellExecute] is\\ngreater than **32**, it indicates a *successful* task launch, and the function\\nreturns `true`. Otherwise, it returns `false`.\\n\\n### Enumerating Running Tasks\\n\\nNext, we\'ll implement the `tasks` getter to **enumerate all running tasks** on\\nthe system.\\n\\n```dart title=\\"task_manager.dart\\"\\n/// Retrieves a list of currently running tasks.\\n///\\n/// Returns `null` if retrieval failed.\\nstatic List<Task>? get tasks {\\n  return using((arena) {\\n    final tasks = <Task>[];\\n\\n    final buffer = arena<Uint32>(1024);\\n    final cbNeeded = arena<Uint32>();\\n\\n    if (EnumProcesses(buffer, sizeOf<Uint32>() * 1024, cbNeeded) == FALSE) {\\n      return null;\\n    }\\n\\n    final processCount = cbNeeded.value ~/ sizeOf<Uint32>();\\n    final processIds = buffer.asTypedList(processCount);\\n\\n    for (final pid in processIds) {\\n      final hProcess = OpenProcess(\\n        PROCESS_QUERY_INFORMATION | PROCESS_VM_READ,\\n        FALSE,\\n        pid,\\n      );\\n\\n      if (hProcess != NULL) {\\n        final hModule = arena<HMODULE>();\\n        final cbNeededMod = arena<Uint32>();\\n\\n        if (EnumProcessModules(\\n                hProcess, hModule, sizeOf<HMODULE>(), cbNeededMod) !=\\n            0) {\\n          final moduleName = arena<WCHAR>(MAX_PATH).cast<Utf16>();\\n\\n          if (GetModuleBaseName(\\n                hProcess,\\n                hModule.value,\\n                moduleName,\\n                MAX_PATH,\\n              ) >\\n              0) {\\n            final name = moduleName.toDartString();\\n\\n            final filePath = arena<WCHAR>(MAX_PATH).cast<Utf16>();\\n            final result = GetModuleFileNameEx(\\n                hProcess, hModule.value, filePath, MAX_PATH);\\n            final path = result != 0 ? filePath.toDartString() : null;\\n\\n            final description =\\n                path != null ? (_getFileDescription(path) ?? name) : name;\\n\\n            final task = Task(\\n              iconAsBytes: path != null\\n                  ? (_extractIcon(path) ?? Uint8List(0))\\n                  : Uint8List(0),\\n              name: name,\\n              pid: pid,\\n              description: description,\\n            );\\n            tasks.add(task);\\n          }\\n        }\\n\\n        CloseHandle(hProcess);\\n      }\\n    }\\n\\n    return tasks;\\n  });\\n}\\n```\\n\\nWe begin by allocating memory for an array of `Uint32` values to store the PIDs\\nof running processes. We then call [EnumProcesses] to retrieve the list of PIDs\\nand the number of processes.\\n\\nNext, we iterate over the list of PIDs and open a handle to each process using\\n[OpenProcess]. We then call [EnumProcessModules] to retrieve the module handle\\nfor the process and [GetModuleBaseName] to retrieve the name of the module.\\n\\nNext, we retrieve the file path of the module using [GetModuleFileNameEx] and\\nextract the file description using the `_getFileDescription` function. We also\\nextract the icon of the task using the `_extractIcon` function. Finally, we\\ncreate a `Task` object with the retrieved information and add it to the list of\\ntasks.\\n\\n#### Retrieving File Description\\n\\nNext, we\'ll implement the `_getFileDescription` function to retrieve the file\\ndescription.\\n\\n```dart title=\\"task_manager.dart\\"\\nstatic String? _getFileDescription(String path) {\\n  return using((arena) {\\n    final lptstrFileName = path.toNativeUtf16(allocator: arena);\\n    final handle = arena<Uint32>();\\n    final size = GetFileVersionInfoSize(lptstrFileName, handle);\\n    if (size == 0) return null;\\n\\n    final versionInfo = arena<Uint8>(size);\\n    if (GetFileVersionInfo(lptstrFileName, 0, size, versionInfo) == FALSE) {\\n      return null;\\n    }\\n\\n    final lplpBuffer = arena<Pointer<Utf16>>();\\n    final puLen = arena<Uint32>();\\n\\n    if (VerQueryValue(\\n          versionInfo,\\n          r\'\\\\StringFileInfo\\\\040904b0\\\\FileDescription\'\\n              .toNativeUtf16(allocator: arena),\\n          lplpBuffer.cast(),\\n          puLen,\\n        ) ==\\n        FALSE) {\\n      return null;\\n    }\\n\\n    if (puLen.value == 0) return null;\\n\\n    return lplpBuffer.value.toDartString();\\n  });\\n}\\n```\\n\\nWe first convert the provided file path into a native UTF-16 format using the\\n`toNativeUtf16` extension method from `package:ffi`. This formatted path is then\\npassed to [GetFileVersionInfoSize] to retrieve the size of the version\\ninformation block for the specified file.\\n\\nNext, we allocate memory for the version information block and call\\n[GetFileVersionInfo] to retrieve the version information for the file.\\n\\nWe then use [VerQueryValue] to retrieve the file description from the version\\ninformation block. If the value is `0`, the function returns `null`. Otherwise,\\nit converts the retrieved value to a Dart string and returns it.\\n\\n#### Extracting Task Icon\\n\\nFinally, we\'ll implement the `_extractIcon` function to extract the icon of the\\ntask.\\n\\n```dart title=\\"task_manager.dart\\"\\nstatic Uint8List? _extractIcon(String path) {\\n  return using((arena) {\\n    final filePath = path.toNativeUtf16(allocator: arena);\\n    final instance = GetModuleHandle(nullptr);\\n    final iconID = arena<WORD>();\\n\\n    final hIcon = ExtractAssociatedIcon(instance, filePath, iconID);\\n    if (hIcon == NULL) return null;\\n\\n    return _getIconData(hIcon);\\n  });\\n}\\n\\nstatic Uint8List? _getIconData(int hIcon, {int nColorBits = 32}) {\\n  return using((arena) {\\n    final buffer = <int>[];\\n    final hdc = CreateCompatibleDC(NULL);\\n\\n    final icoHeader = [0, 0, 1, 0, 1, 0];\\n    buffer.addAll(icoHeader);\\n\\n    final iconInfo = arena<ICONINFO>();\\n    if (GetIconInfo(hIcon, iconInfo) == 0) {\\n      DeleteDC(hdc);\\n      return null;\\n    }\\n\\n    final bmInfo = arena<BITMAPINFO>();\\n    bmInfo.ref.bmiHeader\\n      ..biSize = sizeOf<BITMAPINFOHEADER>()\\n      ..biBitCount = 0;\\n\\n    if (GetDIBits(\\n          hdc,\\n          iconInfo.ref.hbmColor,\\n          0,\\n          0,\\n          nullptr,\\n          bmInfo,\\n          DIB_RGB_COLORS,\\n        ) ==\\n        0) {\\n      DeleteDC(hdc);\\n      return null;\\n    }\\n\\n    int nBmInfoSize = sizeOf<BITMAPINFOHEADER>();\\n    if (nColorBits < 24) {\\n      nBmInfoSize += sizeOf<RGBQUAD>() * (1 << nColorBits);\\n    }\\n\\n    if (bmInfo.ref.bmiHeader.biSizeImage == 0) {\\n      DeleteDC(hdc);\\n      return null;\\n    }\\n\\n    final bits = arena<Uint8>(bmInfo.ref.bmiHeader.biSizeImage);\\n\\n    bmInfo.ref.bmiHeader\\n      ..biBitCount = nColorBits\\n      ..biCompression = BI_RGB;\\n\\n    if (GetDIBits(\\n          hdc,\\n          iconInfo.ref.hbmColor,\\n          0,\\n          bmInfo.ref.bmiHeader.biHeight,\\n          bits,\\n          bmInfo,\\n          DIB_RGB_COLORS,\\n        ) ==\\n        0) {\\n      DeleteDC(hdc);\\n      return null;\\n    }\\n\\n    final maskInfo = arena<BITMAPINFO>();\\n    maskInfo.ref.bmiHeader\\n      ..biSize = sizeOf<BITMAPINFOHEADER>()\\n      ..biBitCount = 0;\\n\\n    if (GetDIBits(\\n              hdc,\\n              iconInfo.ref.hbmMask,\\n              0,\\n              0,\\n              nullptr,\\n              maskInfo,\\n              DIB_RGB_COLORS,\\n            ) ==\\n            0 ||\\n        maskInfo.ref.bmiHeader.biBitCount != 1) {\\n      DeleteDC(hdc);\\n      return null;\\n    }\\n\\n    final maskBits = arena<Uint8>(maskInfo.ref.bmiHeader.biSizeImage);\\n    if (GetDIBits(\\n          hdc,\\n          iconInfo.ref.hbmMask,\\n          0,\\n          maskInfo.ref.bmiHeader.biHeight,\\n          maskBits,\\n          maskInfo,\\n          DIB_RGB_COLORS,\\n        ) ==\\n        0) {\\n      DeleteDC(hdc);\\n      return null;\\n    }\\n\\n    final dir = arena<_IconDirectoryEntry>();\\n    dir.ref\\n      ..nWidth = bmInfo.ref.bmiHeader.biWidth\\n      ..nHeight = bmInfo.ref.bmiHeader.biHeight\\n      ..nNumColorsInPalette = (nColorBits == 4 ? 16 : 0)\\n      ..nNumColorPlanes = 0\\n      ..nBitsPerPixel = bmInfo.ref.bmiHeader.biBitCount\\n      ..nDataLength = bmInfo.ref.bmiHeader.biSizeImage +\\n          maskInfo.ref.bmiHeader.biSizeImage +\\n          nBmInfoSize\\n      ..nOffset = sizeOf<_IconDirectoryEntry>() + 6;\\n\\n    buffer\\n        .addAll(dir.cast<Uint8>().asTypedList(sizeOf<_IconDirectoryEntry>()));\\n\\n    bmInfo.ref.bmiHeader\\n      ..biHeight *= 2\\n      ..biCompression = 0\\n      ..biSizeImage += maskInfo.ref.bmiHeader.biSizeImage;\\n    buffer.addAll(bmInfo.cast<Uint8>().asTypedList(nBmInfoSize));\\n\\n    buffer.addAll(bits.asTypedList(bmInfo.ref.bmiHeader.biSizeImage));\\n    buffer.addAll(maskBits.asTypedList(maskInfo.ref.bmiHeader.biSizeImage));\\n\\n    DeleteObject(iconInfo.ref.hbmColor);\\n    DeleteObject(iconInfo.ref.hbmMask);\\n    DeleteDC(hdc);\\n\\n    return Uint8List.fromList(buffer);\\n  });\\n}\\n\\nbase class _IconDirectoryEntry extends Struct {\\n  @Uint8()\\n  external int nWidth;\\n\\n  @Uint8()\\n  external int nHeight;\\n\\n  @Uint8()\\n  external int nNumColorsInPalette;\\n\\n  @Uint8()\\n  external int nReserved;\\n\\n  @Uint16()\\n  external int nNumColorPlanes;\\n\\n  @Uint16()\\n  external int nBitsPerPixel;\\n\\n  @Uint32()\\n  external int nDataLength;\\n\\n  @Uint32()\\n  external int nOffset;\\n}\\n```\\n\\nWe first convert the provided file path into a native UTF-16 format using the\\n`toNativeUtf16` extension method from `package:ffi`. This formatted path is then\\npassed to [ExtractAssociatedIcon] to retrieve the handle to the associated icon\\nfor the specified file.\\n\\nNext, we call the `_getIconData` function to extract the icon data from the icon\\nhandle. This function retrieves the icon information, including the icon size,\\ncolor depth, and pixel data, and returns it as a `Uint8List`.\\n\\n### Terminating a Task\\n\\nFinally, let\'s implement the `terminate` function to\\n**terminate a running task**.\\n\\n```dart title=\\"task_manager.dart\\"\\n/// Terminates a running task with the given [pid].\\n///\\n/// Returns `true` if the task was successfully terminated; otherwise,\\n/// `false`.\\nstatic bool terminate(int pid) {\\n  final handle = OpenProcess(PROCESS_TERMINATE, FALSE, pid);\\n  if (handle == NULL) return false;\\n\\n  try {\\n    return TerminateProcess(handle, 0) == TRUE;\\n  } finally {\\n    CloseHandle(handle);\\n  }\\n}\\n```\\n\\nWe first attempt to open a handle to the process with the specified PID using\\n[OpenProcess]. If the handle is successfully opened, we proceed to terminate the\\nprocess by calling [TerminateProcess]. If the termination is successful, the\\nfunction returns `true`; otherwise, it returns `false`. Finally, we close the\\nhandle to the process using `CloseHandle` to ensure proper cleanup.\\n\\n## Building the UI\\n\\nWith the task manager logic in place, we can now focus on building the UI for\\nour Task Manager app.\\n\\n### Setting Up the Main Entry Point\\n\\nFirst, open `lib\\\\main.dart` file and replace the contents with the following\\ncode to set up the main entry point for the app:\\n\\n```dart title=\\"main.dart\\"\\nimport \'package:flutter/material.dart\';\\n\\nimport \'models.dart\';\\nimport \'task_manager.dart\';\\n\\nvoid main() {\\n  runApp(const TaskManagerApp());\\n}\\n\\nclass TaskManagerApp extends StatelessWidget {\\n  const TaskManagerApp({super.key});\\n\\n  @override\\n  Widget build(BuildContext context) {\\n    return MaterialApp(\\n      debugShowCheckedModeBanner: false,\\n      title: \'Task Manager\',\\n      theme: ThemeData(\\n        brightness: Brightness.dark,\\n      ),\\n      home: const TaskManagerHomeScreen(),\\n    );\\n  }\\n}\\n```\\n\\n### Creating the Home Screen Skeleton\\n\\nNext, let\'s create the basic structure of the home screen including the\\nStatefulWidget and State class.\\n\\n```dart title=\\"main.dart\\"\\nclass TaskManagerHomeScreen extends StatefulWidget {\\n  const TaskManagerHomeScreen({super.key});\\n\\n  @override\\n  TaskManagerHomeScreenState createState() => TaskManagerHomeScreenState();\\n}\\n\\nclass TaskManagerHomeScreenState extends State<TaskManagerHomeScreen> {\\n  var _tasks = <Task>[];\\n  var _filteredTasks = <Task>[];\\n  int? _selectedTask;\\n  var _sortBy = SortBy.name;\\n  var _sortOrder = SortOrder.ascending;\\n  TextEditingController? _searchController;\\n  FocusNode? _searchFocusNode;\\n\\n  @override\\n  void initState() {\\n    super.initState();\\n    _searchController = TextEditingController();\\n    _searchFocusNode = FocusNode();\\n    loadTasks();\\n  }\\n\\n  @override\\n  void dispose() {\\n    _searchController?.dispose();\\n    _searchFocusNode?.dispose();\\n    super.dispose();\\n  }\\n\\n  @override\\n  Widget build(BuildContext context) {\\n    return Scaffold(\\n      appBar: AppBar(\\n        title: const Text(\'Task Manager\'),\\n        actions: [],\\n      ),\\n      body: const Center(\\n        child: Padding(\\n          padding: EdgeInsets.all(16),\\n          child: Text(\'No tasks found\'),\\n        ),\\n      ),\\n    );\\n  }\\n}\\n```\\n\\n### Loading and Displaying Tasks\\n\\nNow, let\'s implement the method to load tasks, update the state, and use the\\n`DataTable` widget to display tasks.\\n\\n```dart title=\\"main.dart\\"\\nvoid loadTasks() {\\n  setState(() {\\n    _tasks = TaskManager.tasks ?? [];\\n    _filteredTasks = List.from(_tasks);\\n    sortTasks();\\n  });\\n}\\n\\n@override\\nWidget build(BuildContext context) {\\n  return Scaffold(\\n    appBar: // ...\\n    body: CustomScrollView(\\n      slivers: [\\n        SliverToBoxAdapter(\\n          child: _filteredTasks.isEmpty\\n              ? const Center(\\n                  child: Padding(\\n                    padding: EdgeInsets.all(16),\\n                    child: Text(\'No tasks found\'),\\n                  ),\\n                )\\n                // highlight-start\\n              : DataTable(\\n                  columns: [\\n                    const DataColumn(label: Text(\'Name\')),\\n                    const DataColumn(label: Text(\'PID\'), numeric: true),\\n                    const DataColumn(label: Text(\'Description\')),\\n                    const DataColumn(label: Text(\'Actions\')),\\n                  ],\\n                  rows: _filteredTasks.map((task) {\\n                    return DataRow(\\n                      cells: [\\n                        DataCell(Text(task.name)),\\n                        DataCell(Text(task.pid.toString())),\\n                        DataCell(Text(task.description)),\\n                        DataCell(\\n                          IconButton(\\n                            icon: const Icon(\\n                              Icons.cancel_outlined,\\n                              color: Colors.red,\\n                            ),\\n                            onPressed: () {},\\n                          ),\\n                        ),\\n                      ],\\n                    );\\n                  }).toList(),\\n                ),\\n                // highlight-end\\n        ),\\n      ],\\n    ),\\n  );\\n}\\n```\\n\\n### Task Sorting, Searching, and Refreshing\\n\\nNext, let\'s implement the functionality to sort and search tasks based on the\\nuser\'s input and add a button to the app bar to refresh the task list.\\n\\n```dart title=\\"main.dart\\"\\nvoid searchTasks(String query) {\\n  final filtered = _tasks.where((task) {\\n    return task.name.toLowerCase().contains(query.toLowerCase()) ||\\n        task.description.toLowerCase().contains(query.toLowerCase()) ||\\n        task.pid.toString().contains(query);\\n  }).toList();\\n\\n  setState(() {\\n    _filteredTasks = filtered;\\n    sortTasks();\\n  });\\n}\\n\\nvoid sortTasks() {\\n  setState(() {\\n    _filteredTasks.sort((a, b) {\\n      final cmp = switch (_sortBy) {\\n        SortBy.name => a.name.compareTo(b.name),\\n        SortBy.pid => a.pid.compareTo(b.pid),\\n        SortBy.description => a.description.compareTo(b.description),\\n      };\\n      return _sortOrder == SortOrder.ascending ? cmp : -cmp;\\n    });\\n  });\\n}\\n\\n@override\\nWidget build(BuildContext context) {\\n  return Scaffold(\\n    appBar: AppBar(\\n      title: const Text(\'Task Manager\'),\\n      actions: [\\n        // highlight-start\\n        Padding(\\n          padding: const EdgeInsets.symmetric(horizontal: 4),\\n          child: Tooltip(\\n            message: \'Type a name or PID to search\',\\n            child: SizedBox(\\n              height: 40,\\n              width: 300,\\n              child: TextField(\\n                controller: _searchController,\\n                focusNode: _searchFocusNode,\\n                decoration: InputDecoration(\\n                  labelText: \'Type a name or PID to search\',\\n                  border: const OutlineInputBorder(),\\n                  prefixIcon: const Icon(Icons.search),\\n                  suffix: _searchController!.text.isNotEmpty\\n                      ? IconButton(\\n                          icon: const Icon(Icons.clear),\\n                          onPressed: () {\\n                            setState(() {\\n                              _searchController!.clear();\\n                              _searchFocusNode!.unfocus();\\n                              _tasks = TaskManager.tasks ?? [];\\n                              _filteredTasks = List.from(_tasks);\\n                              sortTasks();\\n                            });\\n                          },\\n                        )\\n                      : null,\\n                ),\\n                onChanged: searchTasks,\\n              ),\\n            ),\\n          ),\\n        ),\\n        Padding(\\n          padding: const EdgeInsets.symmetric(horizontal: 4),\\n          child: IconButton(\\n            icon: const Icon(Icons.refresh),\\n            onPressed: () {\\n              setState(() {\\n                _tasks = TaskManager.tasks ?? [];\\n                if (_searchController!.text.isNotEmpty) {\\n                  searchTasks(_searchController!.text);\\n                } else {\\n                  _filteredTasks = List.from(_tasks);\\n                  sortTasks();\\n                }\\n              });\\n            },\\n            tooltip: \'Refresh the list of tasks\',\\n          ),\\n        ),\\n        // highlight-end\\n      ],\\n    ),\\n    body: CustomScrollView(\\n      slivers: [\\n        SliverToBoxAdapter(\\n          child: _filteredTasks.isEmpty\\n              ? const Center(\\n                  child: Padding(\\n                    padding: EdgeInsets.all(16),\\n                    child: Text(\'No tasks found\'),\\n                  ),\\n                )\\n              : DataTable(\\n                  columns: [\\n                    DataColumn(\\n                      label: const Text(\'Name\'),\\n                      // highlight-start\\n                      onSort: (columnIndex, ascending) {\\n                        setState(() {\\n                          _sortBy = SortBy.name;\\n                          _sortOrder = ascending\\n                              ? SortOrder.ascending\\n                              : SortOrder.descending;\\n                          sortTasks();\\n                        });\\n                      },\\n                      // highlight-end\\n                    ),\\n                    DataColumn(\\n                      label: const Text(\'PID\'),\\n                      numeric: true,\\n                      // highlight-start\\n                      onSort: (columnIndex, ascending) {\\n                        setState(() {\\n                          _sortBy = SortBy.pid;\\n                          _sortOrder = ascending\\n                              ? SortOrder.ascending\\n                              : SortOrder.descending;\\n                          sortTasks();\\n                        });\\n                      },\\n                      // highlight-end\\n                      tooltip: \'Process ID\',\\n                    ),\\n                    DataColumn(\\n                      label: const Text(\'Description\'),\\n                      // highlight-start\\n                      onSort: (columnIndex, ascending) {\\n                        setState(() {\\n                          _sortBy = SortBy.description;\\n                          _sortOrder = ascending\\n                              ? SortOrder.ascending\\n                              : SortOrder.descending;\\n                          sortTasks();\\n                        });\\n                      },\\n                      // highlight-end\\n                    ),\\n                    const DataColumn(label: Text(\'Actions\')),\\n                  ],\\n                  rows: // ...\\n                  // highlight-start\\n                  sortAscending: _sortOrder == SortOrder.ascending,\\n                  sortColumnIndex: switch (_sortBy) {\\n                    SortBy.name => 0,\\n                    SortBy.pid => 1,\\n                    SortBy.description => 2,\\n                  },\\n                  // highlight-end\\n                ),\\n        ),\\n      ],\\n    ),\\n  );\\n}\\n```\\n\\n### Task Termination\\n\\nNext, let\'s implement the functionality to terminate a task. We\'ll display a\\nconfirmation dialog to user before terminating the task.\\n\\n```dart title=\\"main.dart\\"\\nvoid confirmEndTask(int pid, String taskName) {\\n  showDialog(\\n    context: context,\\n    builder: (context) {\\n      return AlertDialog(\\n        title: Text(\'Do you want to end $taskName?\'),\\n        content: const Text(\\n          \'If an open program is associated with this process, it will close \'\\n          \'and you will lose any unsaved data. If you end a system process, \'\\n          \'it might result in system instability. Are you sure you want to \'\\n          \'continue?\',\\n        ),\\n        actions: <Widget>[\\n          TextButton(\\n            child: const Text(\'End task\'),\\n            onPressed: () {\\n              Navigator.of(context).pop();\\n              if (TaskManager.terminate(pid)) {\\n                ScaffoldMessenger.of(context).showSnackBar(\\n                  SnackBar(\\n                    content: Text(\'Task \\"$taskName\\" ended successfully\'),\\n                  ),\\n                );\\n                loadTasks();\\n              } else {\\n                ScaffoldMessenger.of(context).showSnackBar(\\n                  SnackBar(\\n                    content: Text(\'Failed to end task \\"$taskName\\"\'),\\n                  ),\\n                );\\n              }\\n            },\\n          ),\\n          TextButton(\\n            child: const Text(\'Cancel\'),\\n            onPressed: () {\\n              Navigator.of(context).pop();\\n            },\\n          ),\\n        ],\\n      );\\n    },\\n  );\\n}\\n\\n@override\\nWidget build(BuildContext context) {\\n  return Scaffold(\\n    appBar: // ...\\n    body: CustomScrollView(\\n      slivers: [\\n        SliverToBoxAdapter(\\n          child: _filteredTasks.isEmpty\\n            ? const Center(\\n                child: Padding(\\n                  padding: EdgeInsets.all(16),\\n                  child: Text(\'No tasks found\'),\\n                ),\\n              )\\n            : DataTable(\\n                columns: // ...\\n                rows: _filteredTasks.map((task) {\\n                  return DataRow(\\n                    cells: [\\n                      // ...\\n                      DataCell(\\n                        IconButton(\\n                          icon: const Icon(\\n                            Icons.cancel_outlined,\\n                            color: Colors.red,\\n                          ),\\n                          // highlight-next-line\\n                          onPressed: () => confirmEndTask(task.pid, task.name),\\n                        ),\\n                      ),\\n                    ],\\n                  );\\n                }).toList(),\\n                // ...\\n              ),\\n        ),\\n      ],\\n    ),\\n  );\\n}\\n```\\n\\n### Task Creation\\n\\nFinally, let\'s implement the functionality to run a new task by displaying a\\ndialog with a text field to the user for entering the task name.\\n\\n```dart title=\\"main.dart\\"\\nvoid runTask(String path) {\\n  final result = TaskManager.run(path);\\n  if (result) {\\n    Navigator.of(context).pop();\\n    ScaffoldMessenger.of(context).showSnackBar(\\n      SnackBar(\\n        content: Text(\'Task \\"$path\\" started successfully\'),\\n      ),\\n    );\\n  } else {\\n    showDialog(\\n      context: context,\\n      builder: (context) {\\n        return AlertDialog(\\n          title: const Text(\'Error\'),\\n          content: Text(\'Failed to run task \\"$path\\"\'),\\n          actions: [\\n            TextButton(\\n              onPressed: () {\\n                Navigator.of(context).pop();\\n              },\\n              child: const Text(\'Ok\'),\\n            ),\\n          ],\\n        );\\n      },\\n    );\\n  }\\n}\\n\\nvoid showRunTaskDialog() {\\n  final taskNameController = TextEditingController();\\n  showDialog(\\n    context: context,\\n    builder: (context) {\\n      return AlertDialog(\\n        title: const Text(\'Run new task\'),\\n        content: TextField(\\n          autofocus: true,\\n          onSubmitted: (_) {\\n            final path = taskNameController.text;\\n            if (path.isNotEmpty) {\\n              runTask(path);\\n            }\\n          },\\n          controller: taskNameController,\\n          decoration: const InputDecoration(hintText: \'Enter task name\'),\\n        ),\\n        actions: [\\n          TextButton(\\n            onPressed: () {\\n              final path = taskNameController.text;\\n              if (path.isNotEmpty) {\\n                runTask(path);\\n              }\\n            },\\n            child: const Text(\'Run\'),\\n          ),\\n          TextButton(\\n            onPressed: () {\\n              Navigator.of(context).pop();\\n            },\\n            child: const Text(\'Cancel\'),\\n          ),\\n        ],\\n      );\\n    },\\n  );\\n}\\n\\n@override\\nWidget build(BuildContext context) {\\n  return Scaffold(\\n    appBar: AppBar(\\n      title: const Text(\'Task Manager\'),\\n      actions: [\\n        // ...\\n        // highlight-start\\n        Padding(\\n          padding: const EdgeInsets.symmetric(horizontal: 4),\\n          child: IconButton(\\n            onPressed: showRunTaskDialog,\\n            icon: const Icon(Icons.add),\\n            tooltip: \'Run a new task\',\\n          ),\\n        ),\\n        // highlight-end\\n      ],\\n    ),\\n    // ...\\n  );\\n}\\n```\\n\\n## Conclusion\\n\\nIn this blog post, we\'ve built an app in Flutter using the **win32** package to\\nmanage running tasks on a Windows system. We\'ve covered the process of\\nenumerating running tasks, starting new tasks, and terminating tasks, as well as\\nbuilding a beautiful UI to interact with the task manager.\\n\\nI hope this tutorial has inspired you to explore further and build even more\\nadvanced applications with Dart, Flutter, and **win32**. Your feedback and\\ncontributions are always welcome, so feel free to share your thoughts and ideas.\\n\\nHappy coding! \uD83D\uDE80\\n\\n## Source Code\\n\\n<CommonViewSourceCode href=\\"https://github.com/halildurmus/win32/tree/main/examples/task_manager\\" />\\n\\n[EnumProcesses]: https://learn.microsoft.com/windows/win32/api/psapi/nf-psapi-enumprocesses\\n[EnumProcessModules]: https://learn.microsoft.com/windows/win32/api/psapi/nf-psapi-enumprocessmodules\\n[ExtractAssociatedIcon]: https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-extractassociatediconw\\n[GetFileVersionInfo]: https://learn.microsoft.com/windows/win32/api/winver/nf-winver-getfileversioninfow\\n[GetFileVersionInfoSize]: https://learn.microsoft.com/windows/win32/api/winver/nf-winver-getfileversioninfosizew\\n[GetModuleBaseName]: https://learn.microsoft.com/windows/win32/api/psapi/nf-psapi-getmodulebasenamew\\n[GetModuleFileNameEx]: https://learn.microsoft.com/windows/win32/api/psapi/nf-psapi-getmodulefilenameexw\\n[OpenProcess]: https://learn.microsoft.com/windows/win32/api/processthreadsapi/nf-processthreadsapi-openprocess\\n[ShellExecute]: https://learn.microsoft.com/windows/win32/api/shellapi/nf-shellapi-shellexecutew\\n[TerminateProcess]: https://learn.microsoft.com/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminateprocess\\n[VerQueryValue]: https://learn.microsoft.com/windows/win32/api/winver/nf-winver-verqueryvaluew"},{"id":"building-service-manager-cli","metadata":{"permalink":"/blog/building-service-manager-cli","source":"@site/blog/2024/07-13-building-service-manager-cli/index.mdx","title":"Building a Service Manager CLI in Dart with win32","description":"We\'ll build a command-line interface (CLI) to manage Windows services in Dart using the win32 package.","date":"2024-07-13T00:00:00.000Z","tags":[{"inline":true,"label":"win32","permalink":"/blog/tags/win-32"},{"inline":true,"label":"dart","permalink":"/blog/tags/dart"},{"inline":true,"label":"tutorial","permalink":"/blog/tags/tutorial"},{"inline":true,"label":"cli","permalink":"/blog/tags/cli"}],"readingTime":18.155,"hasTruncateMarker":true,"authors":[{"name":"Halil Durmus","title":"Software Engineer / Maintainer of win32","url":"https://halildurmus.dev","page":{"permalink":"/blog/authors/halildurmus"},"socials":{"github":"https://github.com/halildurmus"},"github":"https://github.com/halildurmus","imageURL":"https://github.com/halildurmus.png","key":"halildurmus"}],"frontMatter":{"title":"Building a Service Manager CLI in Dart with win32","description":"We\'ll build a command-line interface (CLI) to manage Windows services in Dart using the win32 package.","slug":"building-service-manager-cli","authors":"halildurmus","tags":["win32","dart","tutorial","cli"],"image":"https://ik.imagekit.io/npajaqrcn/blog/2024-07-13-building-service-manager-cli/social.png","hide_table_of_contents":false},"unlisted":false,"prevItem":{"title":"Building a Task Manager App in Flutter with win32","permalink":"/blog/building-task-manager-app"},"nextItem":{"title":"Calling Windows APIs in Dart with win32","permalink":"/blog/calling-windows-apis"}},"content":"## Introduction\\n\\nIn this blog post, we will explore how to build a Service Manager CLI in Dart\\nusing the **win32** package. By leveraging the Windows APIs provided by\\n**win32**, we\'ll create a robust command-line tool that can\\n**enumerate services**, **start and stop services**, and\\n**query service status**.\\n\\nWhether you\'re looking to enhance your development toolkit or simply learn more\\nabout integrating Dart with Windows system functionalities, this guide will\\nprovide you with the insights and steps necessary to build your own service\\nmanager from scratch.\\n\\n\x3c!--truncate--\x3e\\n\\nHere\'s what we\'ll cover:\\n\\n- [Feature Overview](#feature-overview)\\n- [Setting Up the Project](#setting-up-the-project)\\n  - [Creating a New Dart Project](#creating-a-new-dart-project)\\n  - [Installing Dependencies](#installing-dependencies)\\n- [Defining the Models](#defining-the-models)\\n- [Implementing Service Manager Logic](#implementing-service-manager-logic)\\n  - [Enumerating Services](#enumerating-services)\\n  - [Starting a Service](#starting-a-service)\\n  - [Stopping a Service](#stopping-a-service)\\n  - [Querying Service Status](#querying-service-status)\\n- [Building the CLI](#building-the-cli)\\n- [Conclusion](#conclusion)\\n- [Source Code](#source-code)\\n\\n## Feature Overview\\n\\nOur Service Manager CLI will include the following key features:\\n\\n- **Enumerating services:** View a set of all available services on the system.\\n- **Starting and stopping a service:** Start or stop a service by its name.\\n- **Querying service status:** Retrieve the current operational status of a\\n  service by its name.\\n\\n## Setting Up the Project\\n\\nBefore we dive into coding, let\u2019s set up our project.\\n\\n### Creating a New Dart Project\\n\\nOpen your terminal and run:\\n\\n```cmd title=\\"Terminal\\"\\n> dart create service_manager_cli\\n> cd service_manager_cli\\n```\\n\\n### Installing Dependencies\\n\\nAdd the **ffi** and **win32** packages to your project with:\\n\\n```cmd title=\\"Terminal\\"\\ndart pub add ffi win32\\n```\\n\\n## Defining the Models\\n\\nWe\'ll start by defining the models responsible for storing\\n**service information** and result details for **start** and **stop**\\noperations.\\n\\nCreate a new file named `models.dart` in the `lib\\\\src` directory and add the\\nfollowing code:\\n\\n```dart title=\\"lib\\\\src\\\\models.dart\\"\\nimport \'package:win32/win32.dart\';\\n\\n/// The result of an attempt to start a service.\\nenum ServiceStartResult {\\n  /// The attempt to start the service was denied due to insufficient\\n  /// permissions.\\n  accessDenied,\\n\\n  /// The service is already running.\\n  alreadyRunning,\\n\\n  /// The attempt to start the service failed for an unspecified reason.\\n  failed,\\n\\n  /// The service was started successfully.\\n  success,\\n\\n  /// The attempt to start the service timed out.\\n  timedOut,\\n}\\n\\n/// The various states a service can be in.\\nenum ServiceStatus {\\n  /// The service is not running.\\n  stopped,\\n\\n  /// The service is in the process of starting.\\n  startPending,\\n\\n  /// The service is in the process of stopping.\\n  stopPending,\\n\\n  /// The service is running.\\n  running,\\n\\n  /// The service is in the process of resuming from a paused state.\\n  continuePending,\\n\\n  /// The service is in the process of being paused.\\n  pausePending,\\n\\n  /// The service is paused.\\n  paused;\\n\\n  /// Converts an integer value to a corresponding [ServiceStatus] enum.\\n  ///\\n  /// Throws an [ArgumentError] if the value does not correspond to a valid\\n  /// value.\\n  static ServiceStatus fromValue(int value) => switch (value) {\\n        SERVICE_STOPPED => ServiceStatus.stopped,\\n        SERVICE_START_PENDING => ServiceStatus.startPending,\\n        SERVICE_STOP_PENDING => ServiceStatus.stopPending,\\n        SERVICE_RUNNING => ServiceStatus.running,\\n        SERVICE_CONTINUE_PENDING => ServiceStatus.continuePending,\\n        SERVICE_PAUSE_PENDING => ServiceStatus.pausePending,\\n        SERVICE_PAUSED => ServiceStatus.paused,\\n        _ => throw ArgumentError(\'Invalid value: $value\')\\n      };\\n}\\n\\n/// The result of an attempt to stop a service.\\nenum ServiceStopResult {\\n  /// The attempt to stop the service was denied due to insufficient\\n  /// permissions.\\n  accessDenied,\\n\\n  /// The service is already stopped.\\n  alreadyStopped,\\n\\n  /// The attempt to stop the service failed for an unspecified reason.\\n  failed,\\n\\n  /// The service was stopped successfully.\\n  success,\\n\\n  /// The attempt to stop the service timed out.\\n  timedOut,\\n}\\n\\n/// A Windows service with its name, display name, and current status.\\nclass Service {\\n  const Service({\\n    required this.displayName,\\n    required this.name,\\n    required this.status,\\n  });\\n\\n  /// The display name of the service.\\n  final String displayName;\\n\\n  /// The name of the service.\\n  final String name;\\n\\n  /// The current status of the service.\\n  final ServiceStatus status;\\n\\n  @override\\n  String toString() =>\\n      \'Service(displayName: $displayName, name: $name, status: $status)\';\\n}\\n```\\n\\n## Implementing Service Manager Logic\\n\\nNext, we\'ll implement the core functionality for managing Windows services,\\nincluding enumerating services, starting and stopping services, and querying\\nservice status.\\n\\nCreate a new file named `service_manager.dart` in the `lib\\\\src` directory and\\nadd the following code to set up the skeleton for managing Windows services:\\n\\n```dart title=\\"lib\\\\src\\\\service_manager.dart\\"\\nimport \'dart:collection\';\\nimport \'dart:ffi\';\\n\\nimport \'package:ffi/ffi.dart\';\\nimport \'package:win32/win32.dart\';\\n\\nimport \'models.dart\';\\n\\n/// Provides functionality for managing Windows services, including:\\n/// - Enumerating available services\\n/// - Starting and stopping services\\n/// - Retrieving the current status of services\\nabstract class ServiceManager {\\n  /// Whether to log informative messages to the console.\\n  static bool log = false;\\n\\n  /// Retrieves a set of all services (sorted by display name).\\n  static Set<Service> get services {\\n    // TODO: Implement this method\\n    throw UnimplementedError();\\n  }\\n\\n  /// Starts a service defined by [serviceName].\\n  static ServiceStartResult start(String serviceName) {\\n    // TODO: Implement this method\\n    throw UnimplementedError();\\n  }\\n\\n  /// Stops a service defined by [serviceName].\\n  static ServiceStopResult stop(String serviceName) {\\n    // TODO: Implement this method\\n    throw UnimplementedError();\\n  }\\n\\n  /// Retrieves the status of a service defined by [serviceName].\\n  static ServiceStatus? status(String serviceName) {\\n    // TODO: Implement this method\\n    throw UnimplementedError();\\n  }\\n\\n  /// Logs a message to the console if [log] is `true`.\\n  static void _log(String message) {\\n    if (log) print(message);\\n  }\\n}\\n```\\n\\nWith the skeleton in place, we can start implementing the service manager logic.\\n\\n### Enumerating Services\\n\\nNow, let\'s implement the `services` getter to **enumerate all services** on the\\nsystem.\\n\\n```dart title=\\"lib\\\\src\\\\service_manager.dart\\"\\n/// Retrieves a set of all services (sorted by display name).\\nstatic Set<Service> get services {\\n  final services =\\n      SplayTreeSet<Service>((a, b) => a.displayName.compareTo(b.displayName));\\n\\n  // Get a handle to the SCM database.\\n  final scmHandle =\\n      OpenSCManager(nullptr, nullptr, SC_MANAGER_ENUMERATE_SERVICE);\\n  if (scmHandle == NULL) return services;\\n\\n  return using((arena) {\\n    try {\\n      final bytesNeeded = arena<DWORD>();\\n      final servicesReturned = arena<DWORD>();\\n      final resumeHandle = arena<DWORD>();\\n\\n      _log(\'Getting service list...\');\\n\\n      // First call to EnumServicesStatusEx to get the required buffer size.\\n      EnumServicesStatusEx(\\n        scmHandle,\\n        SC_ENUM_PROCESS_INFO,\\n        SERVICE_WIN32,\\n        SERVICE_STATE_ALL,\\n        nullptr,\\n        0,\\n        bytesNeeded,\\n        servicesReturned,\\n        resumeHandle,\\n        nullptr,\\n      );\\n\\n      final buffer = arena<BYTE>(bytesNeeded.value);\\n\\n      // Second call to EnumServicesStatusEx to get the actual data.\\n      if (EnumServicesStatusEx(\\n            scmHandle,\\n            SC_ENUM_PROCESS_INFO,\\n            SERVICE_WIN32,\\n            SERVICE_STATE_ALL,\\n            buffer,\\n            bytesNeeded.value,\\n            bytesNeeded,\\n            servicesReturned,\\n            resumeHandle,\\n            nullptr,\\n          ) !=\\n          FALSE) {\\n        final enumBuffer = buffer.cast<ENUM_SERVICE_STATUS_PROCESS>();\\n        for (var i = 0; i < servicesReturned.value; i++) {\\n          final serviceStatus = (enumBuffer + i).ref;\\n          final ENUM_SERVICE_STATUS_PROCESS(:lpServiceName, :lpDisplayName) =\\n              serviceStatus;\\n          final serviceName = lpServiceName.toDartString();\\n          final displayName = lpDisplayName.toDartString();\\n          final status = ServiceStatus.fromValue(\\n            serviceStatus.ServiceStatusProcess.dwCurrentState,\\n          );\\n          final service = Service(\\n            displayName: displayName,\\n            name: serviceName,\\n            status: status,\\n          );\\n          services.add(service);\\n        }\\n      }\\n    } finally {\\n      CloseServiceHandle(scmHandle);\\n    }\\n\\n    return services;\\n  });\\n}\\n```\\n\\nWe first obtain a handle to the Service Control Manager (SCM) database using\\n[OpenSCManager], which allows us to interact with the SCM to query, start, stop,\\nand configure services. We then make an initial call to [EnumServicesStatusEx]\\nto determine the required buffer size for storing the service information. With\\nthe necessary buffer allocated, we make a second call to `EnumServicesStatusEx`\\nto retrieve the actual service data. Iterating through the services, we convert\\nthem into `Service` objects and add them to a sorted set.\\n\\nThroughout this process, we log informative messages to track progress and\\nerrors. If we fail to open the SCM or enumerate services, we ensure appropriate\\nerror handling and logging.\\n\\n### Starting a Service\\n\\nNext, we\u2019ll implement the `start` function to **start a service** with\\n`serviceName`.\\n\\n```dart title=\\"lib\\\\src\\\\service_manager.dart\\"\\n/// Starts a service defined by [serviceName].\\nstatic ServiceStartResult start(String serviceName) {\\n  // Get a handle to the SCM database.\\n  final scmHandle = OpenSCManager(\\n    nullptr, // local computer\\n    nullptr, // ServicesActive database\\n    SC_MANAGER_ALL_ACCESS, // full access rights\\n  );\\n  if (scmHandle == NULL) return ServiceStartResult.accessDenied;\\n\\n  return using((arena) {\\n    // Get a handle to the service.\\n    final hService = OpenService(\\n      scmHandle,\\n      serviceName.toNativeUtf16(allocator: arena),\\n      SERVICE_ALL_ACCESS,\\n    );\\n    if (hService == NULL) {\\n      CloseServiceHandle(scmHandle);\\n      return ServiceStartResult.failed;\\n    }\\n\\n    final lpBuffer = arena<SERVICE_STATUS_PROCESS>();\\n    final bytesNeeded = arena<DWORD>();\\n\\n    // Check the status in case the service is not stopped.\\n    if (QueryServiceStatusEx(\\n          hService,\\n          SC_STATUS_PROCESS_INFO,\\n          lpBuffer.cast(),\\n          sizeOf<SERVICE_STATUS_PROCESS>(),\\n          bytesNeeded,\\n        ) ==\\n        FALSE) {\\n      CloseServiceHandle(hService);\\n      CloseServiceHandle(scmHandle);\\n      return ServiceStartResult.failed;\\n    }\\n\\n    final ssp = lpBuffer.ref;\\n\\n    // Check if the service is already running. It would be possible to stop\\n    // the service here, but for simplicity this example just returns.\\n    if (ssp.dwCurrentState != SERVICE_STOPPED &&\\n        ssp.dwCurrentState != SERVICE_STOP_PENDING) {\\n      CloseServiceHandle(hService);\\n      CloseServiceHandle(scmHandle);\\n      return ServiceStartResult.alreadyRunning;\\n    }\\n\\n    // Save the tick count and initial checkpoint.\\n    var startTickCount = GetTickCount();\\n    var oldCheckPoint = ssp.dwCheckPoint;\\n\\n    // If a stop is pending, wait for it.\\n    while (ssp.dwCurrentState == SERVICE_STOP_PENDING) {\\n      _log(\'Service stop pending...\');\\n\\n      // Do not wait longer than the wait hint. A good interval is one-tenth\\n      // of the wait hint but not less than 1 second and not more than 10\\n      // seconds.\\n\\n      var waitTime = ssp.dwWaitHint ~/ 10;\\n      waitTime = waitTime < 1000\\n          ? 1000\\n          : waitTime > 10000\\n              ? 10000\\n              : waitTime;\\n      _log(\'Sleeping for ${ssp.dwWaitHint} ms...\');\\n      Sleep(waitTime);\\n\\n      // Check the status until the service is no longer stop pending.\\n      if (QueryServiceStatusEx(\\n            hService,\\n            SC_STATUS_PROCESS_INFO,\\n            lpBuffer.cast(),\\n            sizeOf<SERVICE_STATUS_PROCESS>(),\\n            bytesNeeded,\\n          ) ==\\n          FALSE) {\\n        CloseServiceHandle(hService);\\n        CloseServiceHandle(scmHandle);\\n        return ServiceStartResult.failed;\\n      }\\n\\n      if (ssp.dwCheckPoint > oldCheckPoint) {\\n        // Continue to wait and check.\\n        startTickCount = GetTickCount();\\n        oldCheckPoint = ssp.dwCheckPoint;\\n      } else if (GetTickCount() - startTickCount > ssp.dwWaitHint) {\\n        CloseServiceHandle(hService);\\n        CloseServiceHandle(scmHandle);\\n        return ServiceStartResult.timedOut;\\n      }\\n    }\\n\\n    // Attempt to start the service.\\n    if (StartService(hService, 0, nullptr) == FALSE) {\\n      CloseServiceHandle(hService);\\n      CloseServiceHandle(scmHandle);\\n      return ServiceStartResult.failed;\\n    } else {\\n      _log(\'Service start pending...\');\\n    }\\n\\n    // Check the status until the service is no longer start pending.\\n    if (QueryServiceStatusEx(\\n          hService,\\n          SC_STATUS_PROCESS_INFO,\\n          lpBuffer.cast(),\\n          sizeOf<SERVICE_STATUS_PROCESS>(),\\n          bytesNeeded,\\n        ) ==\\n        FALSE) {\\n      CloseServiceHandle(hService);\\n      CloseServiceHandle(scmHandle);\\n      return ServiceStartResult.failed;\\n    }\\n\\n    // Save the tick count and initial checkpoint.\\n    startTickCount = GetTickCount();\\n    oldCheckPoint = ssp.dwCheckPoint;\\n\\n    while (ssp.dwCurrentState == SERVICE_START_PENDING) {\\n      // Do not wait longer than the wait hint. A good interval is one-tenth\\n      // of the wait hint but not less than 1 second and not more than 10\\n      // seconds.\\n\\n      var waitTime = ssp.dwWaitHint ~/ 10;\\n      waitTime = waitTime < 1000\\n          ? 1000\\n          : waitTime > 10000\\n              ? 10000\\n              : waitTime;\\n      _log(\'Sleeping for ${ssp.dwWaitHint} ms...\');\\n      Sleep(waitTime);\\n\\n      // Check the status again.\\n      if (QueryServiceStatusEx(\\n            hService,\\n            SC_STATUS_PROCESS_INFO,\\n            lpBuffer.cast(),\\n            sizeOf<SERVICE_STATUS_PROCESS>(),\\n            bytesNeeded,\\n          ) ==\\n          FALSE) {\\n        break;\\n      }\\n\\n      if (ssp.dwCheckPoint > oldCheckPoint) {\\n        // Continue to wait and check.\\n        startTickCount = GetTickCount();\\n        oldCheckPoint = ssp.dwCheckPoint;\\n      } else if (GetTickCount() - startTickCount > ssp.dwWaitHint) {\\n        // No progress made within the wait hint.\\n        break;\\n      }\\n    }\\n\\n    // Determine whether the service is running.\\n    final serviceRunning = ssp.dwCurrentState == SERVICE_RUNNING;\\n    CloseServiceHandle(hService);\\n    CloseServiceHandle(scmHandle);\\n\\n    return serviceRunning\\n        ? ServiceStartResult.success\\n        : ServiceStartResult.failed;\\n  });\\n}\\n```\\n\\nWe begin by obtaining a handle to the Service Control Manager (SCM) database\\nusing `OpenSCManager` with full access rights. If this fails, we return an\\n*access denied* result. Next, we get a handle to the specific service using\\n[OpenService]. If this fails, we close the SCM handle and return a *failure*\\nresult.\\n\\nWe then check the service\'s status using [QueryServiceStatusEx]. If the service\\nis not stopped, we return an *already running* result. If the service is\\nstopping, we wait for it to finish stopping, periodically checking its status\\nand updating our wait time based on the service\'s wait hint.\\n\\nOnce the service is stopped, we attempt to start it using [StartService]. We\\nthen check the service\'s status again, waiting for it to finish starting. If the\\nservice starts successfully and transitions to the running state, we return a\\n*success* result; otherwise, we return a *failure* result.\\n\\nThroughout this process, we log informative messages and ensure proper resource\\nmanagement by closing all handles when done.\\n\\n### Stopping a Service\\n\\nNext, we\u2019ll implement the `stop` function to **stop a service** with\\n`serviceName`.\\n\\n```dart title=\\"lib\\\\src\\\\service_manager.dart\\"\\n/// Stops a service defined by [serviceName].\\nstatic ServiceStopResult stop(String serviceName) {\\n  // Get a handle to the SCM database.\\n  final scmHandle = OpenSCManager(\\n    nullptr, // local computer\\n    nullptr, // ServicesActive database\\n    SC_MANAGER_ALL_ACCESS, // full access rights\\n  );\\n  if (scmHandle == NULL) return ServiceStopResult.accessDenied;\\n\\n  return using((arena) {\\n    // Get a handle to the service.\\n    final hService = OpenService(\\n      scmHandle,\\n      serviceName.toNativeUtf16(allocator: arena),\\n      SERVICE_STOP | SERVICE_QUERY_STATUS | SERVICE_ENUMERATE_DEPENDENTS,\\n    );\\n    if (hService == NULL) {\\n      CloseServiceHandle(scmHandle);\\n      return ServiceStopResult.failed;\\n    }\\n\\n    try {\\n      final lpBuffer = arena<SERVICE_STATUS_PROCESS>();\\n      final bytesNeeded = arena<DWORD>();\\n\\n      // Make sure the service is not already stopped.\\n      if (QueryServiceStatusEx(\\n            hService,\\n            SC_STATUS_PROCESS_INFO,\\n            lpBuffer.cast(),\\n            sizeOf<SERVICE_STATUS_PROCESS>(),\\n            bytesNeeded,\\n          ) ==\\n          FALSE) {\\n        return ServiceStopResult.failed;\\n      }\\n\\n      final ssp = lpBuffer.ref;\\n      if (ssp.dwCurrentState == SERVICE_STOPPED) {\\n        return ServiceStopResult.alreadyStopped;\\n      }\\n\\n      final startTime = GetTickCount();\\n      const timeout = 30000; // 30-second timeout\\n\\n      // If a stop is pending, wait for it.\\n      while (ssp.dwCurrentState == SERVICE_STOP_PENDING) {\\n        _log(\'Service stop pending...\');\\n\\n        // Do not wait longer than the wait hint. A good interval is one-tenth\\n        // of the wait hint but not less than 1 second and not more than 10\\n        // seconds.\\n\\n        var waitTime = ssp.dwWaitHint ~/ 10;\\n        waitTime = waitTime < 1000\\n            ? 1000\\n            : waitTime > 10000\\n                ? 10000\\n                : waitTime;\\n        _log(\'Sleeping for ${ssp.dwWaitHint} ms...\');\\n        Sleep(waitTime);\\n\\n        if (QueryServiceStatusEx(\\n              hService,\\n              SC_STATUS_PROCESS_INFO,\\n              lpBuffer.cast(),\\n              sizeOf<SERVICE_STATUS_PROCESS>(),\\n              bytesNeeded,\\n            ) ==\\n            FALSE) {\\n          return ServiceStopResult.failed;\\n        }\\n\\n        if (ssp.dwCurrentState == SERVICE_STOPPED) {\\n          return ServiceStopResult.success;\\n        }\\n\\n        if (GetTickCount() - startTime > timeout) {\\n          return ServiceStopResult.timedOut;\\n        }\\n      }\\n\\n      // If the service is running, dependencies must be stopped first.\\n      final result = _stopDependentServices(hService, scmHandle);\\n      if (result\\n          case ServiceStopResult.accessDenied ||\\n              ServiceStopResult.failed ||\\n              ServiceStopResult.timedOut) {\\n        return result;\\n      }\\n\\n      // Send a stop code to the service.\\n      if (ControlService(\\n            hService,\\n            SERVICE_CONTROL_STOP,\\n            lpBuffer.cast<SERVICE_STATUS>(),\\n          ) ==\\n          FALSE) {\\n        return ServiceStopResult.failed;\\n      }\\n\\n      // Wait for the service to stop.\\n\\n      _log(\'Service stop pending...\');\\n\\n      while (ssp.dwCurrentState != SERVICE_STOPPED) {\\n        _log(\'Sleeping for ${ssp.dwWaitHint} ms...\');\\n        Sleep(ssp.dwWaitHint);\\n\\n        if (QueryServiceStatusEx(\\n              hService,\\n              SC_STATUS_PROCESS_INFO,\\n              lpBuffer.cast(),\\n              sizeOf<SERVICE_STATUS_PROCESS>(),\\n              bytesNeeded,\\n            ) ==\\n            FALSE) {\\n          return ServiceStopResult.failed;\\n        }\\n\\n        if (ssp.dwCurrentState == SERVICE_STOPPED) break;\\n\\n        if (GetTickCount() - startTime > timeout) {\\n          return ServiceStopResult.timedOut;\\n        }\\n      }\\n\\n      return ServiceStopResult.success;\\n    } finally {\\n      CloseServiceHandle(hService);\\n      CloseServiceHandle(scmHandle);\\n    }\\n  });\\n}\\n\\n/// Stops dependent services of a service defined by [hService].\\nstatic ServiceStopResult _stopDependentServices(\\n  int hService,\\n  int scmHandle,\\n) {\\n  return using((arena) {\\n    final bytesNeeded = arena<DWORD>();\\n    final servicesReturned = arena<DWORD>();\\n\\n    _log(\'Checking for dependent services...\');\\n\\n    // Pass a zero-length buffer to get the required buffer size.\\n    if (EnumDependentServices(\\n          hService,\\n          SERVICE_ACTIVE,\\n          nullptr,\\n          0,\\n          bytesNeeded,\\n          servicesReturned,\\n        ) ==\\n        TRUE) {\\n      _log(\'No dependent services found.\');\\n    } else {\\n      // Allocate a buffer for the dependencies.\\n      final lpServices =\\n          arena<BYTE>(bytesNeeded.value).cast<ENUM_SERVICE_STATUS>();\\n\\n      // Enumerate the dependencies.\\n      if (EnumDependentServices(\\n            hService,\\n            SERVICE_ACTIVE,\\n            lpServices,\\n            bytesNeeded.value,\\n            bytesNeeded,\\n            servicesReturned,\\n          ) ==\\n          FALSE) {\\n        return ServiceStopResult.failed;\\n      }\\n\\n      _log(\'Found ${servicesReturned.value} dependent services:\');\\n      for (var i = 0; i < servicesReturned.value; i++) {\\n        final ess = lpServices[i];\\n        _log(\' (${i + 1}/${servicesReturned.value}) Stopping \'\\n            \'${ess.lpServiceName.toDartString()}...\');\\n\\n        // Open the service.\\n        final hDepService = OpenService(\\n          scmHandle,\\n          ess.lpServiceName,\\n          SERVICE_STOP | SERVICE_QUERY_STATUS,\\n        );\\n        if (hDepService == NULL) return ServiceStopResult.failed;\\n\\n        try {\\n          final lpServiceStatus = arena<SERVICE_STATUS_PROCESS>();\\n\\n          // Send a stop code.\\n          if (ControlService(\\n                hDepService,\\n                SERVICE_CONTROL_STOP,\\n                lpServiceStatus.cast<SERVICE_STATUS>(),\\n              ) ==\\n              FALSE) {\\n            return ServiceStopResult.failed;\\n          }\\n\\n          final startTime = GetTickCount();\\n          const timeout = 30000; // 30-second timeout\\n          final ssp = lpServiceStatus.ref;\\n\\n          // Wait for the service to stop.\\n          while (ssp.dwCurrentState != SERVICE_STOPPED) {\\n            _log(\'Sleeping for ${ssp.dwWaitHint} ms...\');\\n            Sleep(ssp.dwWaitHint);\\n\\n            if (QueryServiceStatusEx(\\n                  hDepService,\\n                  SC_STATUS_PROCESS_INFO,\\n                  lpServiceStatus.cast(),\\n                  sizeOf<SERVICE_STATUS_PROCESS>(),\\n                  bytesNeeded,\\n                ) ==\\n                FALSE) {\\n              return ServiceStopResult.failed;\\n            }\\n\\n            if (ssp.dwCurrentState == SERVICE_STOPPED) break;\\n\\n            if (GetTickCount() - startTime > timeout) {\\n              return ServiceStopResult.timedOut;\\n            }\\n          }\\n        } finally {\\n          // Always release the service handle.\\n          CloseServiceHandle(hDepService);\\n        }\\n      }\\n    }\\n\\n    _log(\'Dependent services stopped.\');\\n    return ServiceStopResult.success;\\n  });\\n}\\n```\\n\\nIn the `stop` function, we first obtain a handle to the Service Control Manager\\n(SCM) database using `OpenSCManager` with full access rights. If this fails, we\\nreturn an *access denied* result. Next, we get a handle to the specific service\\nusing `OpenService`, granting it stop, query status, and enumerate dependents\\npermissions. If this fails, we close the SCM handle and return a *failure*\\nresult.\\n\\nWe then check the service\'s status using `QueryServiceStatusEx`. If the service\\nis already stopped, we return an *already stopped* result. If the service is\\nstopping, we wait for it to finish stopping, periodically checking its status\\nand updating our wait time based on the service\'s wait hint. Once the service is\\nno longer in the stop pending state, we attempt to stop any dependent services\\nfirst using the `_stopDependentServices` helper function.\\n\\nAfter ensuring dependent services are stopped, we send a stop code to the\\nservice using [ControlService]. We then wait for the service to transition to\\nthe stopped state, periodically checking its status. If the service stops\\nsuccessfully, we return a *success* result; otherwise, we return a *failure* or\\n*timed out* result.\\n\\nThroughout this process, we log informative messages and ensure proper resource\\nmanagement by closing all handles when done. The `_stopDependentServices`\\nfunction enumerates and stops any active dependent services in a similar manner,\\nensuring they are fully stopped before returning control to the main `stop`\\nfunction.\\n\\n:::note\\n\\nThe implementations for `start` and `stop` functions are based on the C++\\nexamples provided in the [Microsoft documentation].\\n\\n:::\\n\\n### Querying Service Status\\n\\nFinally, let\'s implement the `status` function to **query service status**.\\n\\n```dart title=\\"lib\\\\src\\\\service_manager.dart\\"\\n/// Retrieves the status of a service defined by [serviceName].\\nstatic ServiceStatus? status(String serviceName) {\\n  // Get a handle to the SCM database.\\n  final scmHandle = OpenSCManager(nullptr, nullptr, SC_MANAGER_CONNECT);\\n  if (scmHandle == NULL) return null;\\n\\n  return using((arena) {\\n    // Get a handle to the service.\\n    final hService = OpenService(\\n      scmHandle,\\n      serviceName.toNativeUtf16(allocator: arena),\\n      SERVICE_QUERY_STATUS,\\n    );\\n    if (hService == NULL) {\\n      CloseServiceHandle(scmHandle);\\n      return null;\\n    }\\n\\n    try {\\n      final lpBuffer = arena<SERVICE_STATUS_PROCESS>();\\n      final bytesNeeded = arena<DWORD>();\\n\\n      // Query the service status.\\n      if (QueryServiceStatusEx(\\n            hService,\\n            SC_STATUS_PROCESS_INFO,\\n            lpBuffer.cast(),\\n            sizeOf<SERVICE_STATUS_PROCESS>(),\\n            bytesNeeded,\\n          ) ==\\n          FALSE) {\\n        return null;\\n      }\\n\\n      return ServiceStatus.fromValue(lpBuffer.ref.dwCurrentState);\\n    } finally {\\n      CloseServiceHandle(hService);\\n      CloseServiceHandle(scmHandle);\\n    }\\n  });\\n}\\n```\\n\\nWe first obtain a handle to the Service Control Manager (SCM) database using\\n`OpenSCManager` with connect permissions. If this fails, we return `null`. Next,\\nwe get a handle to the specific service using `OpenService`, granting it query\\nstatus permissions. If this fails, we close the SCM handle and return `null`.\\n\\nUsing the `QueryServiceStatusEx` function, we query the service\'s status. We\\nallocate the necessary buffer to store the status information. If the query is\\n*unsuccessful*, we return `null`. If the query *succeeds*, we retrieve the\\nservice\'s current state and convert it into a `ServiceStatus` object using\\n`ServiceStatus.fromValue`.\\n\\nThroughout this process, we log informative messages and ensure proper resource\\nmanagement by closing all handles when done. This ensures that the function\\ncorrectly retrieves the status of a specified service, returning the appropriate\\nstatus or `null` if any step fails.\\n\\n## Building the CLI\\n\\nNow that we have implemented the functions to interact with Windows services,\\nlet\'s create a CLI tool to manage services directly from the command line.\\n\\nFirst, update the **lib\\\\service_manager_cli.dart** file to export the models and\\nservice manager implementation:\\n\\n```dart title=\\"lib\\\\service_manager_cli.dart\\"\\nlibrary;\\n\\nexport \'src/models.dart\';\\nexport \'src/service_manager.dart\';\\n```\\n\\nNext, replace the existing code in **bin\\\\service_manager_cli.dart** with the\\nfollowing implementation for the CLI:\\n\\n```dart title=\\"bin\\\\service_manager_cli.dart\\"\\nimport \'dart:io\';\\n\\nimport \'package:service_manager_cli/service_manager_cli.dart\';\\n\\nvoid main(List<String> arguments) {\\n  if (arguments.isEmpty ||\\n      arguments.contains(\'-h\') ||\\n      arguments.contains(\'--help\')) {\\n    printUsage();\\n    return;\\n  }\\n\\n  bool verbose = false;\\n  if (arguments.contains(\'-v\') || arguments.contains(\'--verbose\')) {\\n    verbose = true;\\n    arguments = arguments.where((arg) => arg != \'-v\').toList();\\n  }\\n\\n  ServiceManager.log = verbose;\\n\\n  final command = arguments[0];\\n  final serviceName = arguments.length > 1 ? arguments[1] : null;\\n\\n  switch (command) {\\n    case \'list\':\\n      listServices();\\n      break;\\n\\n    case \'start\':\\n      if (serviceName == null) {\\n        print(\'Please provide the service name to start.\');\\n        exit(1);\\n      }\\n      startService(serviceName);\\n      break;\\n\\n    case \'status\':\\n      if (serviceName == null) {\\n        print(\'Please provide a service name to get status.\');\\n        exit(1);\\n      }\\n      status(serviceName);\\n      break;\\n\\n    case \'stop\':\\n      if (serviceName == null) {\\n        print(\'Please provide the service name to stop.\');\\n        exit(1);\\n      }\\n      stopService(serviceName);\\n      break;\\n\\n    default:\\n      print(\'Unknown command: $command\');\\n      print(\'\');\\n      printUsage();\\n      exit(1);\\n  }\\n}\\n\\nvoid printUsage() {\\n  print(\'A command-line interface for managing Windows services.\');\\n  print(\'\');\\n  print(\'Usage: service_manager_cli <command> [arguments]\');\\n  print(\'\');\\n  print(\'Global options:\');\\n  print(\'  -v, --verbose         Show additional command output.\');\\n  print(\'  -h, --help            Print this usage information.\');\\n  print(\'\');\\n  print(\'Available commands:\');\\n  print(\'  list                  List all services.\');\\n  print(\'  start <service_name>  Start a service.\');\\n  print(\'  status <service_name> Get the status of a service.\');\\n  print(\'  stop <service_name>   Stop a service.\');\\n}\\n\\nvoid listServices() {\\n  final services = ServiceManager.services;\\n  if (services.isEmpty) {\\n    print(\'Failed to get services.\');\\n    return;\\n  }\\n\\n  print(\'Found ${services.length} services:\');\\n  for (final service in services) {\\n    print(\' $service\');\\n  }\\n}\\n\\nvoid startService(String serviceName) {\\n  print(switch (ServiceManager.start(serviceName)) {\\n    ServiceStartResult.success =>\\n      \'Service \\"$serviceName\\" started successfully.\',\\n    ServiceStartResult.accessDenied =>\\n      \'The attempt to start the service \\"$serviceName\\" was denied due to \'\\n          \'insufficient permissions.\',\\n    ServiceStartResult.alreadyRunning =>\\n      \'Service \\"$serviceName\\" is already running.\',\\n    ServiceStartResult.failed => \'Failed to start service \\"$serviceName\\".\',\\n    ServiceStartResult.timedOut =>\\n      \'The attempt to start service \\"$serviceName\\" timed out.\'\\n  });\\n}\\n\\nvoid status(String serviceName) {\\n  final status = ServiceManager.status(serviceName);\\n  if (status == null) {\\n    print(\'Failed to get status of service \\"$serviceName\\".\');\\n  } else {\\n    print(\'Status of service \\"$serviceName\\": ${status.name}\');\\n  }\\n}\\n\\nvoid stopService(String serviceName) {\\n  print(switch (ServiceManager.stop(serviceName)) {\\n    ServiceStopResult.success => \'Service \\"$serviceName\\" stopped successfully.\',\\n    ServiceStopResult.accessDenied =>\\n      \'The attempt to stop the service \\"$serviceName\\" was denied due to \'\\n          \'insufficient permissions.\',\\n    ServiceStopResult.alreadyStopped =>\\n      \'Service \\"$serviceName\\" is already stopped.\',\\n    ServiceStopResult.failed => \'Failed to stop service \\"$serviceName\\".\',\\n    ServiceStopResult.timedOut =>\\n      \'The attempt to stop service \\"$serviceName\\" timed out.\'\\n  });\\n}\\n```\\n\\nFinally, update the **pubspec.yaml** file to include the `executables` section\\nand specify the entry point for the CLI:\\n\\n```yaml title=\\"pubspec.yaml\\"\\nname: service_manager_cli\\ndescription: Service Manager CLI\\npublish_to: none\\n\\nenvironment:\\n  sdk: ^3.4.0\\n\\ndependencies:\\n  ffi: ^2.1.2\\n  win32: ^5.5.1\\n\\ndev_dependencies:\\n  lints: ^4.0.0\\n\\n// highlight-start\\nexecutables:\\n  service_manager_cli:\\n// highlight-end\\n```\\n\\nYou now have a powerful CLI tool for efficiently managing Windows services.\\nTo use it, run the following command in your terminal:\\n\\n```cmd title=\\"Terminal\\"\\ndart run service_manager_cli\\n```\\n\\nThis command provides information about available commands, global options, and\\nusage:\\n\\n```text\\nA command-line interface for managing Windows services.\\n\\nUsage: service_manager_cli <command> [arguments]\\n\\nGlobal options:\\n  -v, --verbose         Show additional command output.\\n  -h, --help            Print this usage information.\\nq\\nAvailable commands:\\n  list                  List all services.\\n  start <service_name>  Start a service.\\n  status <service_name> Get the status of a service.\\n  stop <service_name>   Stop a service.\\n```\\n\\n## Conclusion\\n\\nIn this blog post, we\'ve explored how to build a command-line interface (CLI) in\\nDart using the **win32** package to manage Windows services. From listing and\\ncontrolling services to checking their status, we\'ve covered essential tasks\\nthat streamline Windows service administration directly from your command line.\\n\\nI hope you found this tutorial helpful! If you have any questions or feedback,\\nplease feel free to reach out. Happy coding! \uD83D\uDE80\\n\\n## Source Code\\n\\n<CommonViewSourceCode href=\\"https://github.com/halildurmus/win32/tree/main/examples/service_manager_cli\\" />\\n\\n[ControlService]: https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-controlservice\\n[EnumServicesStatusEx]: https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-enumservicesstatusexw\\n[Microsoft documentation]: https://learn.microsoft.com/windows/win32/services/starting-a-service\\n[OpenSCManager]: https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-openscmanagerw\\n[OpenService]: https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-openservicew\\n[QueryServiceStatusEx]: https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-queryservicestatusex\\n[StartService]: https://learn.microsoft.com/windows/win32/api/winsvc/nf-winsvc-startservicew"},{"id":"calling-windows-apis","metadata":{"permalink":"/blog/calling-windows-apis","source":"@site/blog/2024/07-10-calling-windows-apis/index.mdx","title":"Calling Windows APIs in Dart with win32","description":"Learn how to call Windows APIs in Dart with the win32 package. Start with simple examples and explore its wide range of applications.","date":"2024-07-10T00:00:00.000Z","tags":[{"inline":true,"label":"win32","permalink":"/blog/tags/win-32"},{"inline":true,"label":"dart","permalink":"/blog/tags/dart"}],"readingTime":4.875,"hasTruncateMarker":true,"authors":[{"name":"Halil Durmus","title":"Software Engineer / Maintainer of win32","url":"https://halildurmus.dev","page":{"permalink":"/blog/authors/halildurmus"},"socials":{"github":"https://github.com/halildurmus"},"github":"https://github.com/halildurmus","imageURL":"https://github.com/halildurmus.png","key":"halildurmus"}],"frontMatter":{"title":"Calling Windows APIs in Dart with win32","description":"Learn how to call Windows APIs in Dart with the win32 package. Start with simple examples and explore its wide range of applications.","slug":"calling-windows-apis","authors":"halildurmus","tags":["win32","dart"],"image":"https://ik.imagekit.io/npajaqrcn/blog/2024-07-10-calling-windows-apis/social.png","hide_table_of_contents":false,"is_featured":true},"unlisted":false,"prevItem":{"title":"Building a Service Manager CLI in Dart with win32","permalink":"/blog/building-service-manager-cli"}},"content":"## Introduction\\n\\nAs Dart expands its reach beyond web and mobile development, interacting with\\nnative Windows APIs unlocks a world of possibilities. The **win32** package\\nserves as a bridge to the powerful features of the Windows operating system,\\nallowing Dart developers to harness these capabilities directly in their\\napplications.\\n\\nIn this blog post, we\'ll explore how to use the **win32** package to call\\nWindows APIs in Dart, enabling you to create powerful Windows applications with\\nease.\\n\\n\x3c!--truncate--\x3e\\n\\nHere\'s what we\'ll cover:\\n\\n- [What is win32?](#what-is-win32)\\n- [Key Features](#key-features)\\n- [Getting Started](#getting-started)\\n- [Interacting with Windows APIs](#interacting-with-windows-apis)\\n  - [Displaying a Message Box](#displaying-a-message-box)\\n  - [Retrieving the System Memory](#retrieving-the-system-memory)\\n  - [Creating a Classic Win32 Window](#creating-a-classic-win32-window)\\n- [Conclusion](#conclusion)\\n\\n## What is win32?\\n\\n**win32** is a [Dart package] that wraps some of the most common [Win32 API]\\ncalls using [FFI] to make them accessible to Dart code without needing a C\\ncompiler or the Windows SDK.\\n\\nThe package simplifies the process of writing Dart code that can access\\n**Windows hardware** and **system services** by providing easy-to-use bindings\\nfor traditional **Win32** and [COM (Component Object Model)][COM] API calls.\\n\\nWhether you\'re looking to interact with hardware, access system services, or\\nbuild sophisticated desktop applications, **win32** has you covered.\\n\\n### Key Features\\n\\n- **Direct Windows API Access**: Invoke Windows API functions directly from Dart\\n  without the need for a C compiler or additional setup.\\n- **COM Support**: Easily interact with COM libraries and components for\\n  advanced Windows functionalities.\\n- **Extensive API Coverage**: Access a broad range of Windows APIs, including\\n  system services, hardware, and registry.\\n- **Seamless Integration**: Effortlessly integrate with existing Windows\\n  libraries and services, enabling smooth interoperability.\\n- **Cross-Platform Development**: Develop cross-platform packages with specific\\n  implementations tailored for Windows environments.\\n- **Developer-Friendly**: Simplifies the complexity of Win32 API calls into\\n  easy-to-use Dart functions, enhancing developer productivity.\\n\\n## Getting Started\\n\\nLet\'s dive into how you can get started with the **win32** package and see it in\\naction.\\n\\nAdd the **ffi** and **win32** packages to your project with:\\n\\n```cmd title=\\"Terminal\\"\\ndart pub add ffi win32\\n```\\n\\n## Interacting with Windows APIs\\n\\nLet\'s explore how you can interact with thee Windows APIs using the **win32**\\npackage.\\n\\n### Displaying a Message Box\\n\\nLet\'s start with a simple example that displays a message box using the\\n[MessageBox] function from the Windows API.\\n\\n```dart title=\\"main.dart\\"\\nimport \'package:ffi/ffi.dart\';\\nimport \'package:win32/win32.dart\';\\n\\nvoid main() {\\n  final lpCaption = \'Dart MessageBox Demo\'.toNativeUtf16();\\n  final lpText = \'\'\'\\nThis is not really an error, but we are pretending for the sake of this demo.\\n\\nResource error.\\nDo you want to try again?\\n\'\'\'\\n      .toNativeUtf16();\\n\\n  final result = MessageBox(\\n    NULL,\\n    lpText,\\n    lpCaption,\\n    MB_ICONWARNING | // Warning icon\\n        MB_CANCELTRYCONTINUE | // Action button\\n        MB_DEFBUTTON2, // Second button is the default\\n  );\\n\\n  free(lpText);\\n  free(lpCaption);\\n\\n  switch (result) {\\n    case IDCANCEL:\\n      print(\'Cancel pressed\');\\n    case IDTRYAGAIN:\\n      print(\'Try Again pressed\');\\n    case IDCONTINUE:\\n      print(\'Continue pressed\');\\n  }\\n}\\n```\\n\\n![MessageBox](./img/messagebox.png)\\n\\n### Retrieving the System Memory\\n\\nNext, let\'s retrieve the total amount of physical memory installed on the\\nsystem using the [GetPhysicallyInstalledSystemMemory] function.\\n\\n```dart title=\\"main.dart\\"\\nimport \'dart:ffi\';\\n\\nimport \'package:ffi/ffi.dart\';\\nimport \'package:win32/win32.dart\';\\n\\nvoid main() {\\n  final memoryInKB = calloc<ULONGLONG>();\\n\\n  try {\\n    final result = GetPhysicallyInstalledSystemMemory(memoryInKB);\\n    if (result != 0) {\\n      final memoryInMB = memoryInKB.value ~/ 1024;\\n      print(\'System memory: $memoryInMB MB\');\\n    } else {\\n      print(\'Failed to retrieve system memory.\');\\n    }\\n  } finally {\\n    free(memoryInKB);\\n  }\\n}\\n```\\n\\n![System Memory](./img/memory.png)\\n\\n### Creating a Classic Win32 Window\\n\\nFinally, let\'s create a classic Win32 window. First, we\'ll define the window\\nprocedure that will handle messages sent to the window.\\n\\n```dart title=\\"main.dart\\"\\nimport \'dart:ffi\';\\n\\nimport \'package:ffi/ffi.dart\';\\nimport \'package:win32/win32.dart\';\\n\\nint mainWindowProc(int hWnd, int uMsg, int wParam, int lParam) {\\n  switch (uMsg) {\\n    case WM_DESTROY:\\n      PostQuitMessage(0);\\n      return 0;\\n\\n    case WM_PAINT:\\n      final ps = calloc<PAINTSTRUCT>();\\n      final hdc = BeginPaint(hWnd, ps);\\n      final rect = calloc<RECT>();\\n      final msg = \'Hello, Dart!\'.toNativeUtf16();\\n\\n      GetClientRect(hWnd, rect);\\n      DrawText(\\n        hdc,\\n        msg,\\n        -1,\\n        rect,\\n        DT_CENTER |\\n            DT_VCENTER |\\n            DT_SINGLELINE,\\n      );\\n      EndPaint(hWnd, ps);\\n\\n      // Clean up\\n      free(ps);\\n      free(rect);\\n      free(msg);\\n\\n      return 0;\\n  }\\n\\n  return DefWindowProc(hWnd, uMsg, wParam, lParam);\\n}\\n```\\n\\nNext, we\'ll define the `winMain` entry point, which creates the window and runs\\nthe message loop.\\n\\n```dart title=\\"main.dart\\"\\n// ...\\n\\nvoid winMain(int hInstance, List<String> args, int nShowCmd) {\\n  final className = \'Sample Window Class\'.toNativeUtf16();\\n\\n  final lpfnWndProc = NativeCallable<WNDPROC>.isolateLocal(\\n    mainWindowProc,\\n    exceptionalReturn: 0,\\n  );\\n\\n  final wc = calloc<WNDCLASS>();\\n  wc.ref\\n    ..style = CS_HREDRAW | CS_VREDRAW\\n    ..lpfnWndProc = lpfnWndProc.nativeFunction\\n    ..hInstance = hInstance\\n    ..lpszClassName = className\\n    ..hCursor = LoadCursor(NULL, IDC_ARROW)\\n    ..hbrBackground = GetStockObject(WHITE_BRUSH);\\n  RegisterClass(wc);\\n\\n  // Create the window.\\n  final windowCaption = \'Dart Native Win32 window\'.toNativeUtf16();\\n  final hWnd = CreateWindowEx(\\n    0, // Optional window styles.\\n    className, // Window class\\n    windowCaption, // Window caption\\n    WS_OVERLAPPEDWINDOW, // Window style\\n    // Size and position\\n    CW_USEDEFAULT,\\n    CW_USEDEFAULT,\\n    CW_USEDEFAULT,\\n    CW_USEDEFAULT,\\n    NULL, // Parent window\\n    NULL, // Menu\\n    hInstance, // Instance handle\\n    nullptr, // Additional application data\\n  );\\n  free(windowCaption);\\n  free(className);\\n\\n  ShowWindow(hWnd, nShowCmd);\\n  UpdateWindow(hWnd);\\n\\n  // Run the message loop.\\n  final msg = calloc<MSG>();\\n  while (GetMessage(msg, NULL, 0, 0) != 0) {\\n    TranslateMessage(msg);\\n    DispatchMessage(msg);\\n  }\\n\\n  // Clean up\\n  free(msg);\\n  free(wc);\\n  lpfnWndProc.close();\\n}\\n```\\n\\nFinally, we\'ll define the `main` function to initialize the application and call\\nthe `winMain` function. The **win32** package provides the `initApp` helper\\nfunction, which sets up the WinMain function with all the necessary information,\\nincluding the entry point and command line arguments, simplifying the process\\nfor you.\\n\\n```dart title=\\"main.dart\\"\\n// ...\\n\\nvoid main() => initApp(winMain);\\n```\\n\\n![Dart Native Win32 Window](./img/hello.png)\\n\\n## Conclusion\\n\\nThe **win32** package is a powerful tool for Dart developers aiming to leverage\\nthe full capabilities of the Windows operating system. By bridging the gap\\nbetween Dart and the extensive Windows APIs, **win32** enables you to create\\nfeature-rich applications with ease.\\n\\nWhether you\'re displaying simple message boxes, querying system information, or\\ncreating complex graphical interfaces, the **win32** package unlocks new\\npossibilities for your Dart projects. Start exploring today and discover what\\nyou can build with Dart and Windows APIs!\\n\\nFor more detailed information, check out our [documentation](/docs).\\n\\n[COM]: https://learn.microsoft.com/windows/win32/com/component-object-model--com--portal\\n[Dart package]: https://pub.dev/packages/win32\\n[FFI]: https://dart.dev/guides/libraries/c-interop\\n[GetPhysicallyInstalledSystemMemory]: https://docs.microsoft.com/windows/win32/api/sysinfoapi/nf-sysinfoapi-getphysicallyinstalledsystemmemory\\n[MessageBox]: https://learn.microsoft.com/windows/win32/api/winuser/nf-winuser-messagebox\\n[Win32 API]: https://learn.microsoft.com/windows/win32/api/"}]}}')}}]);